Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     program -> PROGRAM IDENTIFIER SEMICOLON block DOT
Rule 3     block -> variable_declaration_part procedure_or_function compound_statement
Rule 4     block -> variable_declaration_part compound_statement
Rule 5     variable_declaration_part -> empty
Rule 6     variable_declaration_part -> VAR variable_declaration_list
Rule 7     variable_declaration_list -> variable_declaration
Rule 8     variable_declaration_list -> variable_declaration variable_declaration_list
Rule 9     variable_declaration -> IDENTIFIER COMMA variable_declaration
Rule 10    variable_declaration -> IDENTIFIER COLON type SEMICOLON
Rule 11    type -> SINTEGER
Rule 12    type -> SCHAR
Rule 13    type -> SREAL
Rule 14    type -> SSTRING
Rule 15    type -> SBOOLEAN
Rule 16    procedure_or_function -> proc_or_func_declaration SEMICOLON procedure_or_function
Rule 17    procedure_or_function -> empty
Rule 18    proc_or_func_declaration -> procedure_declaration
Rule 19    proc_or_func_declaration -> function_declaration
Rule 20    function_declaration -> function_heading SEMICOLON block
Rule 21    function_heading -> FUNCTION type
Rule 22    function_heading -> FUNCTION IDENTIFIER COLON type
Rule 23    function_heading -> FUNCTION IDENTIFIER LPAREN parameters_list RPAREN COLON type
Rule 24    parameters_list -> parameter COMMA parameters_list
Rule 25    parameters_list -> parameter
Rule 26    parameter -> IDENTIFIER COLON type
Rule 27    procedure_declaration -> procedure_heading SEMICOLON block
Rule 28    procedure_heading -> PROCEDURE IDENTIFIER
Rule 29    procedure_heading -> PROCEDURE IDENTIFIER LPAREN parameters_list RPAREN
Rule 30    compound_statement -> BEGIN statement_sequence END
Rule 31    statement_sequence -> statement SEMICOLON statement_sequence
Rule 32    statement_sequence -> statement SEMICOLON
Rule 33    statement -> assignment_statement
Rule 34    statement -> compound_statement
Rule 35    statement -> if_statement
Rule 36    statement -> while_statement
Rule 37    statement -> repeat_statement
Rule 38    statement -> for_statement
Rule 39    statement -> procedure_or_function_call
Rule 40    statement -> empty
Rule 41    procedure_or_function_call -> IDENTIFIER
Rule 42    procedure_or_function_call -> IDENTIFIER LPAREN variables_list RPAREN
Rule 43    variables_list -> variables_list COMMA variable
Rule 44    variables_list -> variable
Rule 45    variable -> expression
Rule 46    assignment_statement -> IDENTIFIER ASSIGNMENT expression
Rule 47    if_statement -> IF expression THEN statement
Rule 48    if_statement -> IF expression THEN statement ELSE statement
Rule 49    while_statement -> WHILE expression DO statement
Rule 50    repeat_statement -> REPEAT statement UNTIL expression
Rule 51    for_statement -> FOR assignment_statement TO expression DO statement
Rule 52    for_statement -> FOR assignment_statement DOWNTO expression DO statement
Rule 53    expression -> expression and_or expression_m
Rule 54    expression -> expression_m
Rule 55    expression_m -> element
Rule 56    expression_m -> expression_m sign element
Rule 57    and_or -> AND
Rule 58    and_or -> OR
Rule 59    sign -> PLUS
Rule 60    sign -> MINUS
Rule 61    sign -> INT_DIV
Rule 62    sign -> FLOAT_DIV
Rule 63    sign -> MULTIPLY
Rule 64    sign -> MOD
Rule 65    sign -> EQ
Rule 66    sign -> NEQ
Rule 67    sign -> LT
Rule 68    sign -> GT
Rule 69    sign -> LTE
Rule 70    sign -> GTE
Rule 71    element -> BOOLEAN
Rule 72    element -> NOT element
Rule 73    element -> IDENTIFIER
Rule 74    element -> REAL
Rule 75    element -> INTEGER
Rule 76    element -> CHAR
Rule 77    element -> STRING
Rule 78    element -> LPAREN expression RPAREN
Rule 79    element -> function_call
Rule 80    function_call -> IDENTIFIER LPAREN variables_list RPAREN

Terminals, with rules where they appear

AND                  : 57
ASSIGNMENT           : 46
BEGIN                : 30
BOOLEAN              : 71
CHAR                 : 76
COLON                : 10 22 23 26
COMMA                : 9 24 43
DO                   : 49 51 52
DOT                  : 2
DOWNTO               : 52
ELSE                 : 48
END                  : 30
EQ                   : 65
FLOAT_DIV            : 62
FOR                  : 51 52
FUNCTION             : 21 22 23
GT                   : 68
GTE                  : 70
IDENTIFIER           : 2 9 10 22 23 26 28 29 41 42 46 73 80
IF                   : 47 48
INTEGER              : 75
INT_DIV              : 61
LPAREN               : 23 29 42 78 80
LT                   : 67
LTE                  : 69
MINUS                : 60
MOD                  : 64
MULTIPLY             : 63
NEQ                  : 66
NOT                  : 72
OR                   : 58
PLUS                 : 59
PROCEDURE            : 28 29
PROGRAM              : 2
REAL                 : 74
REPEAT               : 50
RPAREN               : 23 29 42 78 80
SBOOLEAN             : 15
SCHAR                : 12
SEMICOLON            : 2 10 16 20 27 31 32
SINTEGER             : 11
SREAL                : 13
SSTRING              : 14
STRING               : 77
THEN                 : 47 48
TO                   : 51
UNTIL                : 50
VAR                  : 6
WHILE                : 49
error                : 

Nonterminals, with rules where they appear

and_or               : 53
assignment_statement : 33 51 52
block                : 2 20 27
compound_statement   : 3 4 34
element              : 55 56 72
empty                : 5 17 40
expression           : 45 46 47 48 49 50 51 52 53 78
expression_m         : 53 54 56
for_statement        : 38
function_call        : 79
function_declaration : 19
function_heading     : 20
if_statement         : 35
parameter            : 24 25
parameters_list      : 23 24 29
proc_or_func_declaration : 16
procedure_declaration : 18
procedure_heading    : 27
procedure_or_function : 3 16
procedure_or_function_call : 39
program              : 0
repeat_statement     : 37
sign                 : 56
statement            : 31 32 47 48 48 49 50 51 52
statement_sequence   : 30 31
type                 : 10 21 22 23 26
variable             : 43 44
variable_declaration : 7 8 9
variable_declaration_list : 6 8
variable_declaration_part : 3 4
variables_list       : 42 43 80
while_statement      : 36

Parsing method: LALR

state 0

    (0) S' -> . program
    (2) program -> . PROGRAM IDENTIFIER SEMICOLON block DOT

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (2) program -> PROGRAM . IDENTIFIER SEMICOLON block DOT

    IDENTIFIER      shift and go to state 3


state 3

    (2) program -> PROGRAM IDENTIFIER . SEMICOLON block DOT

    SEMICOLON       shift and go to state 4


state 4

    (2) program -> PROGRAM IDENTIFIER SEMICOLON . block DOT
    (3) block -> . variable_declaration_part procedure_or_function compound_statement
    (4) block -> . variable_declaration_part compound_statement
    (5) variable_declaration_part -> . empty
    (6) variable_declaration_part -> . VAR variable_declaration_list
    (1) empty -> .

    VAR             shift and go to state 8
    BEGIN           reduce using rule 1 (empty -> .)
    PROCEDURE       reduce using rule 1 (empty -> .)
    FUNCTION        reduce using rule 1 (empty -> .)

    block                          shift and go to state 5
    variable_declaration_part      shift and go to state 6
    empty                          shift and go to state 7

state 5

    (2) program -> PROGRAM IDENTIFIER SEMICOLON block . DOT

    DOT             shift and go to state 9


state 6

    (3) block -> variable_declaration_part . procedure_or_function compound_statement
    (4) block -> variable_declaration_part . compound_statement
    (16) procedure_or_function -> . proc_or_func_declaration SEMICOLON procedure_or_function
    (17) procedure_or_function -> . empty
    (30) compound_statement -> . BEGIN statement_sequence END
    (18) proc_or_func_declaration -> . procedure_declaration
    (19) proc_or_func_declaration -> . function_declaration
    (1) empty -> .
    (27) procedure_declaration -> . procedure_heading SEMICOLON block
    (20) function_declaration -> . function_heading SEMICOLON block
    (28) procedure_heading -> . PROCEDURE IDENTIFIER
    (29) procedure_heading -> . PROCEDURE IDENTIFIER LPAREN parameters_list RPAREN
    (21) function_heading -> . FUNCTION type
    (22) function_heading -> . FUNCTION IDENTIFIER COLON type
    (23) function_heading -> . FUNCTION IDENTIFIER LPAREN parameters_list RPAREN COLON type

  ! shift/reduce conflict for BEGIN resolved as shift
    BEGIN           shift and go to state 14
    PROCEDURE       shift and go to state 19
    FUNCTION        shift and go to state 20

  ! BEGIN           [ reduce using rule 1 (empty -> .) ]

    procedure_or_function          shift and go to state 10
    compound_statement             shift and go to state 11
    proc_or_func_declaration       shift and go to state 12
    empty                          shift and go to state 13
    procedure_declaration          shift and go to state 15
    function_declaration           shift and go to state 16
    procedure_heading              shift and go to state 17
    function_heading               shift and go to state 18

state 7

    (5) variable_declaration_part -> empty .

    BEGIN           reduce using rule 5 (variable_declaration_part -> empty .)
    PROCEDURE       reduce using rule 5 (variable_declaration_part -> empty .)
    FUNCTION        reduce using rule 5 (variable_declaration_part -> empty .)


state 8

    (6) variable_declaration_part -> VAR . variable_declaration_list
    (7) variable_declaration_list -> . variable_declaration
    (8) variable_declaration_list -> . variable_declaration variable_declaration_list
    (9) variable_declaration -> . IDENTIFIER COMMA variable_declaration
    (10) variable_declaration -> . IDENTIFIER COLON type SEMICOLON

    IDENTIFIER      shift and go to state 23

    variable_declaration_list      shift and go to state 21
    variable_declaration           shift and go to state 22

state 9

    (2) program -> PROGRAM IDENTIFIER SEMICOLON block DOT .

    $end            reduce using rule 2 (program -> PROGRAM IDENTIFIER SEMICOLON block DOT .)


state 10

    (3) block -> variable_declaration_part procedure_or_function . compound_statement
    (30) compound_statement -> . BEGIN statement_sequence END

    BEGIN           shift and go to state 14

    compound_statement             shift and go to state 24

state 11

    (4) block -> variable_declaration_part compound_statement .

    DOT             reduce using rule 4 (block -> variable_declaration_part compound_statement .)
    SEMICOLON       reduce using rule 4 (block -> variable_declaration_part compound_statement .)


state 12

    (16) procedure_or_function -> proc_or_func_declaration . SEMICOLON procedure_or_function

    SEMICOLON       shift and go to state 25


state 13

    (17) procedure_or_function -> empty .

    BEGIN           reduce using rule 17 (procedure_or_function -> empty .)


state 14

    (30) compound_statement -> BEGIN . statement_sequence END
    (31) statement_sequence -> . statement SEMICOLON statement_sequence
    (32) statement_sequence -> . statement SEMICOLON
    (33) statement -> . assignment_statement
    (34) statement -> . compound_statement
    (35) statement -> . if_statement
    (36) statement -> . while_statement
    (37) statement -> . repeat_statement
    (38) statement -> . for_statement
    (39) statement -> . procedure_or_function_call
    (40) statement -> . empty
    (46) assignment_statement -> . IDENTIFIER ASSIGNMENT expression
    (30) compound_statement -> . BEGIN statement_sequence END
    (47) if_statement -> . IF expression THEN statement
    (48) if_statement -> . IF expression THEN statement ELSE statement
    (49) while_statement -> . WHILE expression DO statement
    (50) repeat_statement -> . REPEAT statement UNTIL expression
    (51) for_statement -> . FOR assignment_statement TO expression DO statement
    (52) for_statement -> . FOR assignment_statement DOWNTO expression DO statement
    (41) procedure_or_function_call -> . IDENTIFIER
    (42) procedure_or_function_call -> . IDENTIFIER LPAREN variables_list RPAREN
    (1) empty -> .

    IDENTIFIER      shift and go to state 36
    BEGIN           shift and go to state 14
    IF              shift and go to state 37
    WHILE           shift and go to state 38
    REPEAT          shift and go to state 39
    FOR             shift and go to state 40
    SEMICOLON       reduce using rule 1 (empty -> .)

    statement_sequence             shift and go to state 26
    statement                      shift and go to state 27
    assignment_statement           shift and go to state 28
    compound_statement             shift and go to state 29
    if_statement                   shift and go to state 30
    while_statement                shift and go to state 31
    repeat_statement               shift and go to state 32
    for_statement                  shift and go to state 33
    procedure_or_function_call     shift and go to state 34
    empty                          shift and go to state 35

state 15

    (18) proc_or_func_declaration -> procedure_declaration .

    SEMICOLON       reduce using rule 18 (proc_or_func_declaration -> procedure_declaration .)


state 16

    (19) proc_or_func_declaration -> function_declaration .

    SEMICOLON       reduce using rule 19 (proc_or_func_declaration -> function_declaration .)


state 17

    (27) procedure_declaration -> procedure_heading . SEMICOLON block

    SEMICOLON       shift and go to state 41


state 18

    (20) function_declaration -> function_heading . SEMICOLON block

    SEMICOLON       shift and go to state 42


state 19

    (28) procedure_heading -> PROCEDURE . IDENTIFIER
    (29) procedure_heading -> PROCEDURE . IDENTIFIER LPAREN parameters_list RPAREN

    IDENTIFIER      shift and go to state 43


state 20

    (21) function_heading -> FUNCTION . type
    (22) function_heading -> FUNCTION . IDENTIFIER COLON type
    (23) function_heading -> FUNCTION . IDENTIFIER LPAREN parameters_list RPAREN COLON type
    (11) type -> . SINTEGER
    (12) type -> . SCHAR
    (13) type -> . SREAL
    (14) type -> . SSTRING
    (15) type -> . SBOOLEAN

    IDENTIFIER      shift and go to state 45
    SINTEGER        shift and go to state 46
    SCHAR           shift and go to state 47
    SREAL           shift and go to state 48
    SSTRING         shift and go to state 49
    SBOOLEAN        shift and go to state 50

    type                           shift and go to state 44

state 21

    (6) variable_declaration_part -> VAR variable_declaration_list .

    BEGIN           reduce using rule 6 (variable_declaration_part -> VAR variable_declaration_list .)
    PROCEDURE       reduce using rule 6 (variable_declaration_part -> VAR variable_declaration_list .)
    FUNCTION        reduce using rule 6 (variable_declaration_part -> VAR variable_declaration_list .)


state 22

    (7) variable_declaration_list -> variable_declaration .
    (8) variable_declaration_list -> variable_declaration . variable_declaration_list
    (7) variable_declaration_list -> . variable_declaration
    (8) variable_declaration_list -> . variable_declaration variable_declaration_list
    (9) variable_declaration -> . IDENTIFIER COMMA variable_declaration
    (10) variable_declaration -> . IDENTIFIER COLON type SEMICOLON

    BEGIN           reduce using rule 7 (variable_declaration_list -> variable_declaration .)
    PROCEDURE       reduce using rule 7 (variable_declaration_list -> variable_declaration .)
    FUNCTION        reduce using rule 7 (variable_declaration_list -> variable_declaration .)
    IDENTIFIER      shift and go to state 23

    variable_declaration           shift and go to state 22
    variable_declaration_list      shift and go to state 51

state 23

    (9) variable_declaration -> IDENTIFIER . COMMA variable_declaration
    (10) variable_declaration -> IDENTIFIER . COLON type SEMICOLON

    COMMA           shift and go to state 52
    COLON           shift and go to state 53


state 24

    (3) block -> variable_declaration_part procedure_or_function compound_statement .

    DOT             reduce using rule 3 (block -> variable_declaration_part procedure_or_function compound_statement .)
    SEMICOLON       reduce using rule 3 (block -> variable_declaration_part procedure_or_function compound_statement .)


state 25

    (16) procedure_or_function -> proc_or_func_declaration SEMICOLON . procedure_or_function
    (16) procedure_or_function -> . proc_or_func_declaration SEMICOLON procedure_or_function
    (17) procedure_or_function -> . empty
    (18) proc_or_func_declaration -> . procedure_declaration
    (19) proc_or_func_declaration -> . function_declaration
    (1) empty -> .
    (27) procedure_declaration -> . procedure_heading SEMICOLON block
    (20) function_declaration -> . function_heading SEMICOLON block
    (28) procedure_heading -> . PROCEDURE IDENTIFIER
    (29) procedure_heading -> . PROCEDURE IDENTIFIER LPAREN parameters_list RPAREN
    (21) function_heading -> . FUNCTION type
    (22) function_heading -> . FUNCTION IDENTIFIER COLON type
    (23) function_heading -> . FUNCTION IDENTIFIER LPAREN parameters_list RPAREN COLON type

    BEGIN           reduce using rule 1 (empty -> .)
    PROCEDURE       shift and go to state 19
    FUNCTION        shift and go to state 20

    proc_or_func_declaration       shift and go to state 12
    procedure_or_function          shift and go to state 54
    empty                          shift and go to state 13
    procedure_declaration          shift and go to state 15
    function_declaration           shift and go to state 16
    procedure_heading              shift and go to state 17
    function_heading               shift and go to state 18

state 26

    (30) compound_statement -> BEGIN statement_sequence . END

    END             shift and go to state 55


state 27

    (31) statement_sequence -> statement . SEMICOLON statement_sequence
    (32) statement_sequence -> statement . SEMICOLON

    SEMICOLON       shift and go to state 56


state 28

    (33) statement -> assignment_statement .

    SEMICOLON       reduce using rule 33 (statement -> assignment_statement .)
    UNTIL           reduce using rule 33 (statement -> assignment_statement .)
    ELSE            reduce using rule 33 (statement -> assignment_statement .)


state 29

    (34) statement -> compound_statement .

    SEMICOLON       reduce using rule 34 (statement -> compound_statement .)
    UNTIL           reduce using rule 34 (statement -> compound_statement .)
    ELSE            reduce using rule 34 (statement -> compound_statement .)


state 30

    (35) statement -> if_statement .

    SEMICOLON       reduce using rule 35 (statement -> if_statement .)
    UNTIL           reduce using rule 35 (statement -> if_statement .)
    ELSE            reduce using rule 35 (statement -> if_statement .)


state 31

    (36) statement -> while_statement .

    SEMICOLON       reduce using rule 36 (statement -> while_statement .)
    UNTIL           reduce using rule 36 (statement -> while_statement .)
    ELSE            reduce using rule 36 (statement -> while_statement .)


state 32

    (37) statement -> repeat_statement .

    SEMICOLON       reduce using rule 37 (statement -> repeat_statement .)
    UNTIL           reduce using rule 37 (statement -> repeat_statement .)
    ELSE            reduce using rule 37 (statement -> repeat_statement .)


state 33

    (38) statement -> for_statement .

    SEMICOLON       reduce using rule 38 (statement -> for_statement .)
    UNTIL           reduce using rule 38 (statement -> for_statement .)
    ELSE            reduce using rule 38 (statement -> for_statement .)


state 34

    (39) statement -> procedure_or_function_call .

    SEMICOLON       reduce using rule 39 (statement -> procedure_or_function_call .)
    UNTIL           reduce using rule 39 (statement -> procedure_or_function_call .)
    ELSE            reduce using rule 39 (statement -> procedure_or_function_call .)


state 35

    (40) statement -> empty .

    SEMICOLON       reduce using rule 40 (statement -> empty .)
    UNTIL           reduce using rule 40 (statement -> empty .)
    ELSE            reduce using rule 40 (statement -> empty .)


state 36

    (46) assignment_statement -> IDENTIFIER . ASSIGNMENT expression
    (41) procedure_or_function_call -> IDENTIFIER .
    (42) procedure_or_function_call -> IDENTIFIER . LPAREN variables_list RPAREN

    ASSIGNMENT      shift and go to state 57
    SEMICOLON       reduce using rule 41 (procedure_or_function_call -> IDENTIFIER .)
    UNTIL           reduce using rule 41 (procedure_or_function_call -> IDENTIFIER .)
    ELSE            reduce using rule 41 (procedure_or_function_call -> IDENTIFIER .)
    LPAREN          shift and go to state 58


state 37

    (47) if_statement -> IF . expression THEN statement
    (48) if_statement -> IF . expression THEN statement ELSE statement
    (53) expression -> . expression and_or expression_m
    (54) expression -> . expression_m
    (55) expression_m -> . element
    (56) expression_m -> . expression_m sign element
    (71) element -> . BOOLEAN
    (72) element -> . NOT element
    (73) element -> . IDENTIFIER
    (74) element -> . REAL
    (75) element -> . INTEGER
    (76) element -> . CHAR
    (77) element -> . STRING
    (78) element -> . LPAREN expression RPAREN
    (79) element -> . function_call
    (80) function_call -> . IDENTIFIER LPAREN variables_list RPAREN

    BOOLEAN         shift and go to state 62
    NOT             shift and go to state 63
    IDENTIFIER      shift and go to state 64
    REAL            shift and go to state 65
    INTEGER         shift and go to state 66
    CHAR            shift and go to state 67
    STRING          shift and go to state 68
    LPAREN          shift and go to state 69

    expression                     shift and go to state 59
    expression_m                   shift and go to state 60
    element                        shift and go to state 61
    function_call                  shift and go to state 70

state 38

    (49) while_statement -> WHILE . expression DO statement
    (53) expression -> . expression and_or expression_m
    (54) expression -> . expression_m
    (55) expression_m -> . element
    (56) expression_m -> . expression_m sign element
    (71) element -> . BOOLEAN
    (72) element -> . NOT element
    (73) element -> . IDENTIFIER
    (74) element -> . REAL
    (75) element -> . INTEGER
    (76) element -> . CHAR
    (77) element -> . STRING
    (78) element -> . LPAREN expression RPAREN
    (79) element -> . function_call
    (80) function_call -> . IDENTIFIER LPAREN variables_list RPAREN

    BOOLEAN         shift and go to state 62
    NOT             shift and go to state 63
    IDENTIFIER      shift and go to state 64
    REAL            shift and go to state 65
    INTEGER         shift and go to state 66
    CHAR            shift and go to state 67
    STRING          shift and go to state 68
    LPAREN          shift and go to state 69

    expression                     shift and go to state 71
    expression_m                   shift and go to state 60
    element                        shift and go to state 61
    function_call                  shift and go to state 70

state 39

    (50) repeat_statement -> REPEAT . statement UNTIL expression
    (33) statement -> . assignment_statement
    (34) statement -> . compound_statement
    (35) statement -> . if_statement
    (36) statement -> . while_statement
    (37) statement -> . repeat_statement
    (38) statement -> . for_statement
    (39) statement -> . procedure_or_function_call
    (40) statement -> . empty
    (46) assignment_statement -> . IDENTIFIER ASSIGNMENT expression
    (30) compound_statement -> . BEGIN statement_sequence END
    (47) if_statement -> . IF expression THEN statement
    (48) if_statement -> . IF expression THEN statement ELSE statement
    (49) while_statement -> . WHILE expression DO statement
    (50) repeat_statement -> . REPEAT statement UNTIL expression
    (51) for_statement -> . FOR assignment_statement TO expression DO statement
    (52) for_statement -> . FOR assignment_statement DOWNTO expression DO statement
    (41) procedure_or_function_call -> . IDENTIFIER
    (42) procedure_or_function_call -> . IDENTIFIER LPAREN variables_list RPAREN
    (1) empty -> .

    IDENTIFIER      shift and go to state 36
    BEGIN           shift and go to state 14
    IF              shift and go to state 37
    WHILE           shift and go to state 38
    REPEAT          shift and go to state 39
    FOR             shift and go to state 40
    UNTIL           reduce using rule 1 (empty -> .)

    statement                      shift and go to state 72
    assignment_statement           shift and go to state 28
    compound_statement             shift and go to state 29
    if_statement                   shift and go to state 30
    while_statement                shift and go to state 31
    repeat_statement               shift and go to state 32
    for_statement                  shift and go to state 33
    procedure_or_function_call     shift and go to state 34
    empty                          shift and go to state 35

state 40

    (51) for_statement -> FOR . assignment_statement TO expression DO statement
    (52) for_statement -> FOR . assignment_statement DOWNTO expression DO statement
    (46) assignment_statement -> . IDENTIFIER ASSIGNMENT expression

    IDENTIFIER      shift and go to state 74

    assignment_statement           shift and go to state 73

state 41

    (27) procedure_declaration -> procedure_heading SEMICOLON . block
    (3) block -> . variable_declaration_part procedure_or_function compound_statement
    (4) block -> . variable_declaration_part compound_statement
    (5) variable_declaration_part -> . empty
    (6) variable_declaration_part -> . VAR variable_declaration_list
    (1) empty -> .

    VAR             shift and go to state 8
    BEGIN           reduce using rule 1 (empty -> .)
    PROCEDURE       reduce using rule 1 (empty -> .)
    FUNCTION        reduce using rule 1 (empty -> .)

    block                          shift and go to state 75
    variable_declaration_part      shift and go to state 6
    empty                          shift and go to state 7

state 42

    (20) function_declaration -> function_heading SEMICOLON . block
    (3) block -> . variable_declaration_part procedure_or_function compound_statement
    (4) block -> . variable_declaration_part compound_statement
    (5) variable_declaration_part -> . empty
    (6) variable_declaration_part -> . VAR variable_declaration_list
    (1) empty -> .

    VAR             shift and go to state 8
    BEGIN           reduce using rule 1 (empty -> .)
    PROCEDURE       reduce using rule 1 (empty -> .)
    FUNCTION        reduce using rule 1 (empty -> .)

    block                          shift and go to state 76
    variable_declaration_part      shift and go to state 6
    empty                          shift and go to state 7

state 43

    (28) procedure_heading -> PROCEDURE IDENTIFIER .
    (29) procedure_heading -> PROCEDURE IDENTIFIER . LPAREN parameters_list RPAREN

    SEMICOLON       reduce using rule 28 (procedure_heading -> PROCEDURE IDENTIFIER .)
    LPAREN          shift and go to state 77


state 44

    (21) function_heading -> FUNCTION type .

    SEMICOLON       reduce using rule 21 (function_heading -> FUNCTION type .)


state 45

    (22) function_heading -> FUNCTION IDENTIFIER . COLON type
    (23) function_heading -> FUNCTION IDENTIFIER . LPAREN parameters_list RPAREN COLON type

    COLON           shift and go to state 78
    LPAREN          shift and go to state 79


state 46

    (11) type -> SINTEGER .

    SEMICOLON       reduce using rule 11 (type -> SINTEGER .)
    COMMA           reduce using rule 11 (type -> SINTEGER .)
    RPAREN          reduce using rule 11 (type -> SINTEGER .)


state 47

    (12) type -> SCHAR .

    SEMICOLON       reduce using rule 12 (type -> SCHAR .)
    COMMA           reduce using rule 12 (type -> SCHAR .)
    RPAREN          reduce using rule 12 (type -> SCHAR .)


state 48

    (13) type -> SREAL .

    SEMICOLON       reduce using rule 13 (type -> SREAL .)
    COMMA           reduce using rule 13 (type -> SREAL .)
    RPAREN          reduce using rule 13 (type -> SREAL .)


state 49

    (14) type -> SSTRING .

    SEMICOLON       reduce using rule 14 (type -> SSTRING .)
    COMMA           reduce using rule 14 (type -> SSTRING .)
    RPAREN          reduce using rule 14 (type -> SSTRING .)


state 50

    (15) type -> SBOOLEAN .

    SEMICOLON       reduce using rule 15 (type -> SBOOLEAN .)
    COMMA           reduce using rule 15 (type -> SBOOLEAN .)
    RPAREN          reduce using rule 15 (type -> SBOOLEAN .)


state 51

    (8) variable_declaration_list -> variable_declaration variable_declaration_list .

    BEGIN           reduce using rule 8 (variable_declaration_list -> variable_declaration variable_declaration_list .)
    PROCEDURE       reduce using rule 8 (variable_declaration_list -> variable_declaration variable_declaration_list .)
    FUNCTION        reduce using rule 8 (variable_declaration_list -> variable_declaration variable_declaration_list .)


state 52

    (9) variable_declaration -> IDENTIFIER COMMA . variable_declaration
    (9) variable_declaration -> . IDENTIFIER COMMA variable_declaration
    (10) variable_declaration -> . IDENTIFIER COLON type SEMICOLON

    IDENTIFIER      shift and go to state 23

    variable_declaration           shift and go to state 80

state 53

    (10) variable_declaration -> IDENTIFIER COLON . type SEMICOLON
    (11) type -> . SINTEGER
    (12) type -> . SCHAR
    (13) type -> . SREAL
    (14) type -> . SSTRING
    (15) type -> . SBOOLEAN

    SINTEGER        shift and go to state 46
    SCHAR           shift and go to state 47
    SREAL           shift and go to state 48
    SSTRING         shift and go to state 49
    SBOOLEAN        shift and go to state 50

    type                           shift and go to state 81

state 54

    (16) procedure_or_function -> proc_or_func_declaration SEMICOLON procedure_or_function .

    BEGIN           reduce using rule 16 (procedure_or_function -> proc_or_func_declaration SEMICOLON procedure_or_function .)


state 55

    (30) compound_statement -> BEGIN statement_sequence END .

    DOT             reduce using rule 30 (compound_statement -> BEGIN statement_sequence END .)
    SEMICOLON       reduce using rule 30 (compound_statement -> BEGIN statement_sequence END .)
    UNTIL           reduce using rule 30 (compound_statement -> BEGIN statement_sequence END .)
    ELSE            reduce using rule 30 (compound_statement -> BEGIN statement_sequence END .)


state 56

    (31) statement_sequence -> statement SEMICOLON . statement_sequence
    (32) statement_sequence -> statement SEMICOLON .
    (31) statement_sequence -> . statement SEMICOLON statement_sequence
    (32) statement_sequence -> . statement SEMICOLON
    (33) statement -> . assignment_statement
    (34) statement -> . compound_statement
    (35) statement -> . if_statement
    (36) statement -> . while_statement
    (37) statement -> . repeat_statement
    (38) statement -> . for_statement
    (39) statement -> . procedure_or_function_call
    (40) statement -> . empty
    (46) assignment_statement -> . IDENTIFIER ASSIGNMENT expression
    (30) compound_statement -> . BEGIN statement_sequence END
    (47) if_statement -> . IF expression THEN statement
    (48) if_statement -> . IF expression THEN statement ELSE statement
    (49) while_statement -> . WHILE expression DO statement
    (50) repeat_statement -> . REPEAT statement UNTIL expression
    (51) for_statement -> . FOR assignment_statement TO expression DO statement
    (52) for_statement -> . FOR assignment_statement DOWNTO expression DO statement
    (41) procedure_or_function_call -> . IDENTIFIER
    (42) procedure_or_function_call -> . IDENTIFIER LPAREN variables_list RPAREN
    (1) empty -> .

    END             reduce using rule 32 (statement_sequence -> statement SEMICOLON .)
    IDENTIFIER      shift and go to state 36
    BEGIN           shift and go to state 14
    IF              shift and go to state 37
    WHILE           shift and go to state 38
    REPEAT          shift and go to state 39
    FOR             shift and go to state 40
    SEMICOLON       reduce using rule 1 (empty -> .)

    statement                      shift and go to state 27
    statement_sequence             shift and go to state 82
    assignment_statement           shift and go to state 28
    compound_statement             shift and go to state 29
    if_statement                   shift and go to state 30
    while_statement                shift and go to state 31
    repeat_statement               shift and go to state 32
    for_statement                  shift and go to state 33
    procedure_or_function_call     shift and go to state 34
    empty                          shift and go to state 35

state 57

    (46) assignment_statement -> IDENTIFIER ASSIGNMENT . expression
    (53) expression -> . expression and_or expression_m
    (54) expression -> . expression_m
    (55) expression_m -> . element
    (56) expression_m -> . expression_m sign element
    (71) element -> . BOOLEAN
    (72) element -> . NOT element
    (73) element -> . IDENTIFIER
    (74) element -> . REAL
    (75) element -> . INTEGER
    (76) element -> . CHAR
    (77) element -> . STRING
    (78) element -> . LPAREN expression RPAREN
    (79) element -> . function_call
    (80) function_call -> . IDENTIFIER LPAREN variables_list RPAREN

    BOOLEAN         shift and go to state 62
    NOT             shift and go to state 63
    IDENTIFIER      shift and go to state 64
    REAL            shift and go to state 65
    INTEGER         shift and go to state 66
    CHAR            shift and go to state 67
    STRING          shift and go to state 68
    LPAREN          shift and go to state 69

    expression                     shift and go to state 83
    expression_m                   shift and go to state 60
    element                        shift and go to state 61
    function_call                  shift and go to state 70

state 58

    (42) procedure_or_function_call -> IDENTIFIER LPAREN . variables_list RPAREN
    (43) variables_list -> . variables_list COMMA variable
    (44) variables_list -> . variable
    (45) variable -> . expression
    (53) expression -> . expression and_or expression_m
    (54) expression -> . expression_m
    (55) expression_m -> . element
    (56) expression_m -> . expression_m sign element
    (71) element -> . BOOLEAN
    (72) element -> . NOT element
    (73) element -> . IDENTIFIER
    (74) element -> . REAL
    (75) element -> . INTEGER
    (76) element -> . CHAR
    (77) element -> . STRING
    (78) element -> . LPAREN expression RPAREN
    (79) element -> . function_call
    (80) function_call -> . IDENTIFIER LPAREN variables_list RPAREN

    BOOLEAN         shift and go to state 62
    NOT             shift and go to state 63
    IDENTIFIER      shift and go to state 64
    REAL            shift and go to state 65
    INTEGER         shift and go to state 66
    CHAR            shift and go to state 67
    STRING          shift and go to state 68
    LPAREN          shift and go to state 69

    variables_list                 shift and go to state 84
    variable                       shift and go to state 85
    expression                     shift and go to state 86
    expression_m                   shift and go to state 60
    element                        shift and go to state 61
    function_call                  shift and go to state 70

state 59

    (47) if_statement -> IF expression . THEN statement
    (48) if_statement -> IF expression . THEN statement ELSE statement
    (53) expression -> expression . and_or expression_m
    (57) and_or -> . AND
    (58) and_or -> . OR

    THEN            shift and go to state 87
    AND             shift and go to state 89
    OR              shift and go to state 90

    and_or                         shift and go to state 88

state 60

    (54) expression -> expression_m .
    (56) expression_m -> expression_m . sign element
    (59) sign -> . PLUS
    (60) sign -> . MINUS
    (61) sign -> . INT_DIV
    (62) sign -> . FLOAT_DIV
    (63) sign -> . MULTIPLY
    (64) sign -> . MOD
    (65) sign -> . EQ
    (66) sign -> . NEQ
    (67) sign -> . LT
    (68) sign -> . GT
    (69) sign -> . LTE
    (70) sign -> . GTE

    THEN            reduce using rule 54 (expression -> expression_m .)
    AND             reduce using rule 54 (expression -> expression_m .)
    OR              reduce using rule 54 (expression -> expression_m .)
    DO              reduce using rule 54 (expression -> expression_m .)
    SEMICOLON       reduce using rule 54 (expression -> expression_m .)
    UNTIL           reduce using rule 54 (expression -> expression_m .)
    TO              reduce using rule 54 (expression -> expression_m .)
    DOWNTO          reduce using rule 54 (expression -> expression_m .)
    ELSE            reduce using rule 54 (expression -> expression_m .)
    RPAREN          reduce using rule 54 (expression -> expression_m .)
    COMMA           reduce using rule 54 (expression -> expression_m .)
    PLUS            shift and go to state 92
    MINUS           shift and go to state 93
    INT_DIV         shift and go to state 94
    FLOAT_DIV       shift and go to state 95
    MULTIPLY        shift and go to state 96
    MOD             shift and go to state 97
    EQ              shift and go to state 98
    NEQ             shift and go to state 99
    LT              shift and go to state 100
    GT              shift and go to state 101
    LTE             shift and go to state 102
    GTE             shift and go to state 103

    sign                           shift and go to state 91

state 61

    (55) expression_m -> element .

    PLUS            reduce using rule 55 (expression_m -> element .)
    MINUS           reduce using rule 55 (expression_m -> element .)
    INT_DIV         reduce using rule 55 (expression_m -> element .)
    FLOAT_DIV       reduce using rule 55 (expression_m -> element .)
    MULTIPLY        reduce using rule 55 (expression_m -> element .)
    MOD             reduce using rule 55 (expression_m -> element .)
    EQ              reduce using rule 55 (expression_m -> element .)
    NEQ             reduce using rule 55 (expression_m -> element .)
    LT              reduce using rule 55 (expression_m -> element .)
    GT              reduce using rule 55 (expression_m -> element .)
    LTE             reduce using rule 55 (expression_m -> element .)
    GTE             reduce using rule 55 (expression_m -> element .)
    THEN            reduce using rule 55 (expression_m -> element .)
    AND             reduce using rule 55 (expression_m -> element .)
    OR              reduce using rule 55 (expression_m -> element .)
    DO              reduce using rule 55 (expression_m -> element .)
    SEMICOLON       reduce using rule 55 (expression_m -> element .)
    UNTIL           reduce using rule 55 (expression_m -> element .)
    TO              reduce using rule 55 (expression_m -> element .)
    DOWNTO          reduce using rule 55 (expression_m -> element .)
    ELSE            reduce using rule 55 (expression_m -> element .)
    RPAREN          reduce using rule 55 (expression_m -> element .)
    COMMA           reduce using rule 55 (expression_m -> element .)


state 62

    (71) element -> BOOLEAN .

    PLUS            reduce using rule 71 (element -> BOOLEAN .)
    MINUS           reduce using rule 71 (element -> BOOLEAN .)
    INT_DIV         reduce using rule 71 (element -> BOOLEAN .)
    FLOAT_DIV       reduce using rule 71 (element -> BOOLEAN .)
    MULTIPLY        reduce using rule 71 (element -> BOOLEAN .)
    MOD             reduce using rule 71 (element -> BOOLEAN .)
    EQ              reduce using rule 71 (element -> BOOLEAN .)
    NEQ             reduce using rule 71 (element -> BOOLEAN .)
    LT              reduce using rule 71 (element -> BOOLEAN .)
    GT              reduce using rule 71 (element -> BOOLEAN .)
    LTE             reduce using rule 71 (element -> BOOLEAN .)
    GTE             reduce using rule 71 (element -> BOOLEAN .)
    THEN            reduce using rule 71 (element -> BOOLEAN .)
    AND             reduce using rule 71 (element -> BOOLEAN .)
    OR              reduce using rule 71 (element -> BOOLEAN .)
    DO              reduce using rule 71 (element -> BOOLEAN .)
    SEMICOLON       reduce using rule 71 (element -> BOOLEAN .)
    UNTIL           reduce using rule 71 (element -> BOOLEAN .)
    TO              reduce using rule 71 (element -> BOOLEAN .)
    DOWNTO          reduce using rule 71 (element -> BOOLEAN .)
    ELSE            reduce using rule 71 (element -> BOOLEAN .)
    RPAREN          reduce using rule 71 (element -> BOOLEAN .)
    COMMA           reduce using rule 71 (element -> BOOLEAN .)


state 63

    (72) element -> NOT . element
    (71) element -> . BOOLEAN
    (72) element -> . NOT element
    (73) element -> . IDENTIFIER
    (74) element -> . REAL
    (75) element -> . INTEGER
    (76) element -> . CHAR
    (77) element -> . STRING
    (78) element -> . LPAREN expression RPAREN
    (79) element -> . function_call
    (80) function_call -> . IDENTIFIER LPAREN variables_list RPAREN

    BOOLEAN         shift and go to state 62
    NOT             shift and go to state 63
    IDENTIFIER      shift and go to state 64
    REAL            shift and go to state 65
    INTEGER         shift and go to state 66
    CHAR            shift and go to state 67
    STRING          shift and go to state 68
    LPAREN          shift and go to state 69

    element                        shift and go to state 104
    function_call                  shift and go to state 70

state 64

    (73) element -> IDENTIFIER .
    (80) function_call -> IDENTIFIER . LPAREN variables_list RPAREN

    PLUS            reduce using rule 73 (element -> IDENTIFIER .)
    MINUS           reduce using rule 73 (element -> IDENTIFIER .)
    INT_DIV         reduce using rule 73 (element -> IDENTIFIER .)
    FLOAT_DIV       reduce using rule 73 (element -> IDENTIFIER .)
    MULTIPLY        reduce using rule 73 (element -> IDENTIFIER .)
    MOD             reduce using rule 73 (element -> IDENTIFIER .)
    EQ              reduce using rule 73 (element -> IDENTIFIER .)
    NEQ             reduce using rule 73 (element -> IDENTIFIER .)
    LT              reduce using rule 73 (element -> IDENTIFIER .)
    GT              reduce using rule 73 (element -> IDENTIFIER .)
    LTE             reduce using rule 73 (element -> IDENTIFIER .)
    GTE             reduce using rule 73 (element -> IDENTIFIER .)
    THEN            reduce using rule 73 (element -> IDENTIFIER .)
    AND             reduce using rule 73 (element -> IDENTIFIER .)
    OR              reduce using rule 73 (element -> IDENTIFIER .)
    DO              reduce using rule 73 (element -> IDENTIFIER .)
    SEMICOLON       reduce using rule 73 (element -> IDENTIFIER .)
    UNTIL           reduce using rule 73 (element -> IDENTIFIER .)
    TO              reduce using rule 73 (element -> IDENTIFIER .)
    DOWNTO          reduce using rule 73 (element -> IDENTIFIER .)
    ELSE            reduce using rule 73 (element -> IDENTIFIER .)
    RPAREN          reduce using rule 73 (element -> IDENTIFIER .)
    COMMA           reduce using rule 73 (element -> IDENTIFIER .)
    LPAREN          shift and go to state 105


state 65

    (74) element -> REAL .

    PLUS            reduce using rule 74 (element -> REAL .)
    MINUS           reduce using rule 74 (element -> REAL .)
    INT_DIV         reduce using rule 74 (element -> REAL .)
    FLOAT_DIV       reduce using rule 74 (element -> REAL .)
    MULTIPLY        reduce using rule 74 (element -> REAL .)
    MOD             reduce using rule 74 (element -> REAL .)
    EQ              reduce using rule 74 (element -> REAL .)
    NEQ             reduce using rule 74 (element -> REAL .)
    LT              reduce using rule 74 (element -> REAL .)
    GT              reduce using rule 74 (element -> REAL .)
    LTE             reduce using rule 74 (element -> REAL .)
    GTE             reduce using rule 74 (element -> REAL .)
    THEN            reduce using rule 74 (element -> REAL .)
    AND             reduce using rule 74 (element -> REAL .)
    OR              reduce using rule 74 (element -> REAL .)
    DO              reduce using rule 74 (element -> REAL .)
    SEMICOLON       reduce using rule 74 (element -> REAL .)
    UNTIL           reduce using rule 74 (element -> REAL .)
    TO              reduce using rule 74 (element -> REAL .)
    DOWNTO          reduce using rule 74 (element -> REAL .)
    ELSE            reduce using rule 74 (element -> REAL .)
    RPAREN          reduce using rule 74 (element -> REAL .)
    COMMA           reduce using rule 74 (element -> REAL .)


state 66

    (75) element -> INTEGER .

    PLUS            reduce using rule 75 (element -> INTEGER .)
    MINUS           reduce using rule 75 (element -> INTEGER .)
    INT_DIV         reduce using rule 75 (element -> INTEGER .)
    FLOAT_DIV       reduce using rule 75 (element -> INTEGER .)
    MULTIPLY        reduce using rule 75 (element -> INTEGER .)
    MOD             reduce using rule 75 (element -> INTEGER .)
    EQ              reduce using rule 75 (element -> INTEGER .)
    NEQ             reduce using rule 75 (element -> INTEGER .)
    LT              reduce using rule 75 (element -> INTEGER .)
    GT              reduce using rule 75 (element -> INTEGER .)
    LTE             reduce using rule 75 (element -> INTEGER .)
    GTE             reduce using rule 75 (element -> INTEGER .)
    THEN            reduce using rule 75 (element -> INTEGER .)
    AND             reduce using rule 75 (element -> INTEGER .)
    OR              reduce using rule 75 (element -> INTEGER .)
    DO              reduce using rule 75 (element -> INTEGER .)
    SEMICOLON       reduce using rule 75 (element -> INTEGER .)
    UNTIL           reduce using rule 75 (element -> INTEGER .)
    TO              reduce using rule 75 (element -> INTEGER .)
    DOWNTO          reduce using rule 75 (element -> INTEGER .)
    ELSE            reduce using rule 75 (element -> INTEGER .)
    RPAREN          reduce using rule 75 (element -> INTEGER .)
    COMMA           reduce using rule 75 (element -> INTEGER .)


state 67

    (76) element -> CHAR .

    PLUS            reduce using rule 76 (element -> CHAR .)
    MINUS           reduce using rule 76 (element -> CHAR .)
    INT_DIV         reduce using rule 76 (element -> CHAR .)
    FLOAT_DIV       reduce using rule 76 (element -> CHAR .)
    MULTIPLY        reduce using rule 76 (element -> CHAR .)
    MOD             reduce using rule 76 (element -> CHAR .)
    EQ              reduce using rule 76 (element -> CHAR .)
    NEQ             reduce using rule 76 (element -> CHAR .)
    LT              reduce using rule 76 (element -> CHAR .)
    GT              reduce using rule 76 (element -> CHAR .)
    LTE             reduce using rule 76 (element -> CHAR .)
    GTE             reduce using rule 76 (element -> CHAR .)
    THEN            reduce using rule 76 (element -> CHAR .)
    AND             reduce using rule 76 (element -> CHAR .)
    OR              reduce using rule 76 (element -> CHAR .)
    DO              reduce using rule 76 (element -> CHAR .)
    SEMICOLON       reduce using rule 76 (element -> CHAR .)
    UNTIL           reduce using rule 76 (element -> CHAR .)
    TO              reduce using rule 76 (element -> CHAR .)
    DOWNTO          reduce using rule 76 (element -> CHAR .)
    ELSE            reduce using rule 76 (element -> CHAR .)
    RPAREN          reduce using rule 76 (element -> CHAR .)
    COMMA           reduce using rule 76 (element -> CHAR .)


state 68

    (77) element -> STRING .

    PLUS            reduce using rule 77 (element -> STRING .)
    MINUS           reduce using rule 77 (element -> STRING .)
    INT_DIV         reduce using rule 77 (element -> STRING .)
    FLOAT_DIV       reduce using rule 77 (element -> STRING .)
    MULTIPLY        reduce using rule 77 (element -> STRING .)
    MOD             reduce using rule 77 (element -> STRING .)
    EQ              reduce using rule 77 (element -> STRING .)
    NEQ             reduce using rule 77 (element -> STRING .)
    LT              reduce using rule 77 (element -> STRING .)
    GT              reduce using rule 77 (element -> STRING .)
    LTE             reduce using rule 77 (element -> STRING .)
    GTE             reduce using rule 77 (element -> STRING .)
    THEN            reduce using rule 77 (element -> STRING .)
    AND             reduce using rule 77 (element -> STRING .)
    OR              reduce using rule 77 (element -> STRING .)
    DO              reduce using rule 77 (element -> STRING .)
    SEMICOLON       reduce using rule 77 (element -> STRING .)
    UNTIL           reduce using rule 77 (element -> STRING .)
    TO              reduce using rule 77 (element -> STRING .)
    DOWNTO          reduce using rule 77 (element -> STRING .)
    ELSE            reduce using rule 77 (element -> STRING .)
    RPAREN          reduce using rule 77 (element -> STRING .)
    COMMA           reduce using rule 77 (element -> STRING .)


state 69

    (78) element -> LPAREN . expression RPAREN
    (53) expression -> . expression and_or expression_m
    (54) expression -> . expression_m
    (55) expression_m -> . element
    (56) expression_m -> . expression_m sign element
    (71) element -> . BOOLEAN
    (72) element -> . NOT element
    (73) element -> . IDENTIFIER
    (74) element -> . REAL
    (75) element -> . INTEGER
    (76) element -> . CHAR
    (77) element -> . STRING
    (78) element -> . LPAREN expression RPAREN
    (79) element -> . function_call
    (80) function_call -> . IDENTIFIER LPAREN variables_list RPAREN

    BOOLEAN         shift and go to state 62
    NOT             shift and go to state 63
    IDENTIFIER      shift and go to state 64
    REAL            shift and go to state 65
    INTEGER         shift and go to state 66
    CHAR            shift and go to state 67
    STRING          shift and go to state 68
    LPAREN          shift and go to state 69

    expression                     shift and go to state 106
    expression_m                   shift and go to state 60
    element                        shift and go to state 61
    function_call                  shift and go to state 70

state 70

    (79) element -> function_call .

    PLUS            reduce using rule 79 (element -> function_call .)
    MINUS           reduce using rule 79 (element -> function_call .)
    INT_DIV         reduce using rule 79 (element -> function_call .)
    FLOAT_DIV       reduce using rule 79 (element -> function_call .)
    MULTIPLY        reduce using rule 79 (element -> function_call .)
    MOD             reduce using rule 79 (element -> function_call .)
    EQ              reduce using rule 79 (element -> function_call .)
    NEQ             reduce using rule 79 (element -> function_call .)
    LT              reduce using rule 79 (element -> function_call .)
    GT              reduce using rule 79 (element -> function_call .)
    LTE             reduce using rule 79 (element -> function_call .)
    GTE             reduce using rule 79 (element -> function_call .)
    THEN            reduce using rule 79 (element -> function_call .)
    AND             reduce using rule 79 (element -> function_call .)
    OR              reduce using rule 79 (element -> function_call .)
    DO              reduce using rule 79 (element -> function_call .)
    SEMICOLON       reduce using rule 79 (element -> function_call .)
    UNTIL           reduce using rule 79 (element -> function_call .)
    TO              reduce using rule 79 (element -> function_call .)
    DOWNTO          reduce using rule 79 (element -> function_call .)
    ELSE            reduce using rule 79 (element -> function_call .)
    RPAREN          reduce using rule 79 (element -> function_call .)
    COMMA           reduce using rule 79 (element -> function_call .)


state 71

    (49) while_statement -> WHILE expression . DO statement
    (53) expression -> expression . and_or expression_m
    (57) and_or -> . AND
    (58) and_or -> . OR

    DO              shift and go to state 107
    AND             shift and go to state 89
    OR              shift and go to state 90

    and_or                         shift and go to state 88

state 72

    (50) repeat_statement -> REPEAT statement . UNTIL expression

    UNTIL           shift and go to state 108


state 73

    (51) for_statement -> FOR assignment_statement . TO expression DO statement
    (52) for_statement -> FOR assignment_statement . DOWNTO expression DO statement

    TO              shift and go to state 109
    DOWNTO          shift and go to state 110


state 74

    (46) assignment_statement -> IDENTIFIER . ASSIGNMENT expression

    ASSIGNMENT      shift and go to state 57


state 75

    (27) procedure_declaration -> procedure_heading SEMICOLON block .

    SEMICOLON       reduce using rule 27 (procedure_declaration -> procedure_heading SEMICOLON block .)


state 76

    (20) function_declaration -> function_heading SEMICOLON block .

    SEMICOLON       reduce using rule 20 (function_declaration -> function_heading SEMICOLON block .)


state 77

    (29) procedure_heading -> PROCEDURE IDENTIFIER LPAREN . parameters_list RPAREN
    (24) parameters_list -> . parameter COMMA parameters_list
    (25) parameters_list -> . parameter
    (26) parameter -> . IDENTIFIER COLON type

    IDENTIFIER      shift and go to state 111

    parameters_list                shift and go to state 112
    parameter                      shift and go to state 113

state 78

    (22) function_heading -> FUNCTION IDENTIFIER COLON . type
    (11) type -> . SINTEGER
    (12) type -> . SCHAR
    (13) type -> . SREAL
    (14) type -> . SSTRING
    (15) type -> . SBOOLEAN

    SINTEGER        shift and go to state 46
    SCHAR           shift and go to state 47
    SREAL           shift and go to state 48
    SSTRING         shift and go to state 49
    SBOOLEAN        shift and go to state 50

    type                           shift and go to state 114

state 79

    (23) function_heading -> FUNCTION IDENTIFIER LPAREN . parameters_list RPAREN COLON type
    (24) parameters_list -> . parameter COMMA parameters_list
    (25) parameters_list -> . parameter
    (26) parameter -> . IDENTIFIER COLON type

    IDENTIFIER      shift and go to state 111

    parameters_list                shift and go to state 115
    parameter                      shift and go to state 113

state 80

    (9) variable_declaration -> IDENTIFIER COMMA variable_declaration .

    IDENTIFIER      reduce using rule 9 (variable_declaration -> IDENTIFIER COMMA variable_declaration .)
    BEGIN           reduce using rule 9 (variable_declaration -> IDENTIFIER COMMA variable_declaration .)
    PROCEDURE       reduce using rule 9 (variable_declaration -> IDENTIFIER COMMA variable_declaration .)
    FUNCTION        reduce using rule 9 (variable_declaration -> IDENTIFIER COMMA variable_declaration .)


state 81

    (10) variable_declaration -> IDENTIFIER COLON type . SEMICOLON

    SEMICOLON       shift and go to state 116


state 82

    (31) statement_sequence -> statement SEMICOLON statement_sequence .

    END             reduce using rule 31 (statement_sequence -> statement SEMICOLON statement_sequence .)


state 83

    (46) assignment_statement -> IDENTIFIER ASSIGNMENT expression .
    (53) expression -> expression . and_or expression_m
    (57) and_or -> . AND
    (58) and_or -> . OR

    SEMICOLON       reduce using rule 46 (assignment_statement -> IDENTIFIER ASSIGNMENT expression .)
    UNTIL           reduce using rule 46 (assignment_statement -> IDENTIFIER ASSIGNMENT expression .)
    TO              reduce using rule 46 (assignment_statement -> IDENTIFIER ASSIGNMENT expression .)
    DOWNTO          reduce using rule 46 (assignment_statement -> IDENTIFIER ASSIGNMENT expression .)
    ELSE            reduce using rule 46 (assignment_statement -> IDENTIFIER ASSIGNMENT expression .)
    AND             shift and go to state 89
    OR              shift and go to state 90

    and_or                         shift and go to state 88

state 84

    (42) procedure_or_function_call -> IDENTIFIER LPAREN variables_list . RPAREN
    (43) variables_list -> variables_list . COMMA variable

    RPAREN          shift and go to state 117
    COMMA           shift and go to state 118


state 85

    (44) variables_list -> variable .

    RPAREN          reduce using rule 44 (variables_list -> variable .)
    COMMA           reduce using rule 44 (variables_list -> variable .)


state 86

    (45) variable -> expression .
    (53) expression -> expression . and_or expression_m
    (57) and_or -> . AND
    (58) and_or -> . OR

    RPAREN          reduce using rule 45 (variable -> expression .)
    COMMA           reduce using rule 45 (variable -> expression .)
    AND             shift and go to state 89
    OR              shift and go to state 90

    and_or                         shift and go to state 88

state 87

    (47) if_statement -> IF expression THEN . statement
    (48) if_statement -> IF expression THEN . statement ELSE statement
    (33) statement -> . assignment_statement
    (34) statement -> . compound_statement
    (35) statement -> . if_statement
    (36) statement -> . while_statement
    (37) statement -> . repeat_statement
    (38) statement -> . for_statement
    (39) statement -> . procedure_or_function_call
    (40) statement -> . empty
    (46) assignment_statement -> . IDENTIFIER ASSIGNMENT expression
    (30) compound_statement -> . BEGIN statement_sequence END
    (47) if_statement -> . IF expression THEN statement
    (48) if_statement -> . IF expression THEN statement ELSE statement
    (49) while_statement -> . WHILE expression DO statement
    (50) repeat_statement -> . REPEAT statement UNTIL expression
    (51) for_statement -> . FOR assignment_statement TO expression DO statement
    (52) for_statement -> . FOR assignment_statement DOWNTO expression DO statement
    (41) procedure_or_function_call -> . IDENTIFIER
    (42) procedure_or_function_call -> . IDENTIFIER LPAREN variables_list RPAREN
    (1) empty -> .

    IDENTIFIER      shift and go to state 36
    BEGIN           shift and go to state 14
    IF              shift and go to state 37
    WHILE           shift and go to state 38
    REPEAT          shift and go to state 39
    FOR             shift and go to state 40
    ELSE            reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    UNTIL           reduce using rule 1 (empty -> .)

    statement                      shift and go to state 119
    assignment_statement           shift and go to state 28
    compound_statement             shift and go to state 29
    if_statement                   shift and go to state 30
    while_statement                shift and go to state 31
    repeat_statement               shift and go to state 32
    for_statement                  shift and go to state 33
    procedure_or_function_call     shift and go to state 34
    empty                          shift and go to state 35

state 88

    (53) expression -> expression and_or . expression_m
    (55) expression_m -> . element
    (56) expression_m -> . expression_m sign element
    (71) element -> . BOOLEAN
    (72) element -> . NOT element
    (73) element -> . IDENTIFIER
    (74) element -> . REAL
    (75) element -> . INTEGER
    (76) element -> . CHAR
    (77) element -> . STRING
    (78) element -> . LPAREN expression RPAREN
    (79) element -> . function_call
    (80) function_call -> . IDENTIFIER LPAREN variables_list RPAREN

    BOOLEAN         shift and go to state 62
    NOT             shift and go to state 63
    IDENTIFIER      shift and go to state 64
    REAL            shift and go to state 65
    INTEGER         shift and go to state 66
    CHAR            shift and go to state 67
    STRING          shift and go to state 68
    LPAREN          shift and go to state 69

    expression_m                   shift and go to state 120
    element                        shift and go to state 61
    function_call                  shift and go to state 70

state 89

    (57) and_or -> AND .

    BOOLEAN         reduce using rule 57 (and_or -> AND .)
    NOT             reduce using rule 57 (and_or -> AND .)
    IDENTIFIER      reduce using rule 57 (and_or -> AND .)
    REAL            reduce using rule 57 (and_or -> AND .)
    INTEGER         reduce using rule 57 (and_or -> AND .)
    CHAR            reduce using rule 57 (and_or -> AND .)
    STRING          reduce using rule 57 (and_or -> AND .)
    LPAREN          reduce using rule 57 (and_or -> AND .)


state 90

    (58) and_or -> OR .

    BOOLEAN         reduce using rule 58 (and_or -> OR .)
    NOT             reduce using rule 58 (and_or -> OR .)
    IDENTIFIER      reduce using rule 58 (and_or -> OR .)
    REAL            reduce using rule 58 (and_or -> OR .)
    INTEGER         reduce using rule 58 (and_or -> OR .)
    CHAR            reduce using rule 58 (and_or -> OR .)
    STRING          reduce using rule 58 (and_or -> OR .)
    LPAREN          reduce using rule 58 (and_or -> OR .)


state 91

    (56) expression_m -> expression_m sign . element
    (71) element -> . BOOLEAN
    (72) element -> . NOT element
    (73) element -> . IDENTIFIER
    (74) element -> . REAL
    (75) element -> . INTEGER
    (76) element -> . CHAR
    (77) element -> . STRING
    (78) element -> . LPAREN expression RPAREN
    (79) element -> . function_call
    (80) function_call -> . IDENTIFIER LPAREN variables_list RPAREN

    BOOLEAN         shift and go to state 62
    NOT             shift and go to state 63
    IDENTIFIER      shift and go to state 64
    REAL            shift and go to state 65
    INTEGER         shift and go to state 66
    CHAR            shift and go to state 67
    STRING          shift and go to state 68
    LPAREN          shift and go to state 69

    element                        shift and go to state 121
    function_call                  shift and go to state 70

state 92

    (59) sign -> PLUS .

    BOOLEAN         reduce using rule 59 (sign -> PLUS .)
    NOT             reduce using rule 59 (sign -> PLUS .)
    IDENTIFIER      reduce using rule 59 (sign -> PLUS .)
    REAL            reduce using rule 59 (sign -> PLUS .)
    INTEGER         reduce using rule 59 (sign -> PLUS .)
    CHAR            reduce using rule 59 (sign -> PLUS .)
    STRING          reduce using rule 59 (sign -> PLUS .)
    LPAREN          reduce using rule 59 (sign -> PLUS .)


state 93

    (60) sign -> MINUS .

    BOOLEAN         reduce using rule 60 (sign -> MINUS .)
    NOT             reduce using rule 60 (sign -> MINUS .)
    IDENTIFIER      reduce using rule 60 (sign -> MINUS .)
    REAL            reduce using rule 60 (sign -> MINUS .)
    INTEGER         reduce using rule 60 (sign -> MINUS .)
    CHAR            reduce using rule 60 (sign -> MINUS .)
    STRING          reduce using rule 60 (sign -> MINUS .)
    LPAREN          reduce using rule 60 (sign -> MINUS .)


state 94

    (61) sign -> INT_DIV .

    BOOLEAN         reduce using rule 61 (sign -> INT_DIV .)
    NOT             reduce using rule 61 (sign -> INT_DIV .)
    IDENTIFIER      reduce using rule 61 (sign -> INT_DIV .)
    REAL            reduce using rule 61 (sign -> INT_DIV .)
    INTEGER         reduce using rule 61 (sign -> INT_DIV .)
    CHAR            reduce using rule 61 (sign -> INT_DIV .)
    STRING          reduce using rule 61 (sign -> INT_DIV .)
    LPAREN          reduce using rule 61 (sign -> INT_DIV .)


state 95

    (62) sign -> FLOAT_DIV .

    BOOLEAN         reduce using rule 62 (sign -> FLOAT_DIV .)
    NOT             reduce using rule 62 (sign -> FLOAT_DIV .)
    IDENTIFIER      reduce using rule 62 (sign -> FLOAT_DIV .)
    REAL            reduce using rule 62 (sign -> FLOAT_DIV .)
    INTEGER         reduce using rule 62 (sign -> FLOAT_DIV .)
    CHAR            reduce using rule 62 (sign -> FLOAT_DIV .)
    STRING          reduce using rule 62 (sign -> FLOAT_DIV .)
    LPAREN          reduce using rule 62 (sign -> FLOAT_DIV .)


state 96

    (63) sign -> MULTIPLY .

    BOOLEAN         reduce using rule 63 (sign -> MULTIPLY .)
    NOT             reduce using rule 63 (sign -> MULTIPLY .)
    IDENTIFIER      reduce using rule 63 (sign -> MULTIPLY .)
    REAL            reduce using rule 63 (sign -> MULTIPLY .)
    INTEGER         reduce using rule 63 (sign -> MULTIPLY .)
    CHAR            reduce using rule 63 (sign -> MULTIPLY .)
    STRING          reduce using rule 63 (sign -> MULTIPLY .)
    LPAREN          reduce using rule 63 (sign -> MULTIPLY .)


state 97

    (64) sign -> MOD .

    BOOLEAN         reduce using rule 64 (sign -> MOD .)
    NOT             reduce using rule 64 (sign -> MOD .)
    IDENTIFIER      reduce using rule 64 (sign -> MOD .)
    REAL            reduce using rule 64 (sign -> MOD .)
    INTEGER         reduce using rule 64 (sign -> MOD .)
    CHAR            reduce using rule 64 (sign -> MOD .)
    STRING          reduce using rule 64 (sign -> MOD .)
    LPAREN          reduce using rule 64 (sign -> MOD .)


state 98

    (65) sign -> EQ .

    BOOLEAN         reduce using rule 65 (sign -> EQ .)
    NOT             reduce using rule 65 (sign -> EQ .)
    IDENTIFIER      reduce using rule 65 (sign -> EQ .)
    REAL            reduce using rule 65 (sign -> EQ .)
    INTEGER         reduce using rule 65 (sign -> EQ .)
    CHAR            reduce using rule 65 (sign -> EQ .)
    STRING          reduce using rule 65 (sign -> EQ .)
    LPAREN          reduce using rule 65 (sign -> EQ .)


state 99

    (66) sign -> NEQ .

    BOOLEAN         reduce using rule 66 (sign -> NEQ .)
    NOT             reduce using rule 66 (sign -> NEQ .)
    IDENTIFIER      reduce using rule 66 (sign -> NEQ .)
    REAL            reduce using rule 66 (sign -> NEQ .)
    INTEGER         reduce using rule 66 (sign -> NEQ .)
    CHAR            reduce using rule 66 (sign -> NEQ .)
    STRING          reduce using rule 66 (sign -> NEQ .)
    LPAREN          reduce using rule 66 (sign -> NEQ .)


state 100

    (67) sign -> LT .

    BOOLEAN         reduce using rule 67 (sign -> LT .)
    NOT             reduce using rule 67 (sign -> LT .)
    IDENTIFIER      reduce using rule 67 (sign -> LT .)
    REAL            reduce using rule 67 (sign -> LT .)
    INTEGER         reduce using rule 67 (sign -> LT .)
    CHAR            reduce using rule 67 (sign -> LT .)
    STRING          reduce using rule 67 (sign -> LT .)
    LPAREN          reduce using rule 67 (sign -> LT .)


state 101

    (68) sign -> GT .

    BOOLEAN         reduce using rule 68 (sign -> GT .)
    NOT             reduce using rule 68 (sign -> GT .)
    IDENTIFIER      reduce using rule 68 (sign -> GT .)
    REAL            reduce using rule 68 (sign -> GT .)
    INTEGER         reduce using rule 68 (sign -> GT .)
    CHAR            reduce using rule 68 (sign -> GT .)
    STRING          reduce using rule 68 (sign -> GT .)
    LPAREN          reduce using rule 68 (sign -> GT .)


state 102

    (69) sign -> LTE .

    BOOLEAN         reduce using rule 69 (sign -> LTE .)
    NOT             reduce using rule 69 (sign -> LTE .)
    IDENTIFIER      reduce using rule 69 (sign -> LTE .)
    REAL            reduce using rule 69 (sign -> LTE .)
    INTEGER         reduce using rule 69 (sign -> LTE .)
    CHAR            reduce using rule 69 (sign -> LTE .)
    STRING          reduce using rule 69 (sign -> LTE .)
    LPAREN          reduce using rule 69 (sign -> LTE .)


state 103

    (70) sign -> GTE .

    BOOLEAN         reduce using rule 70 (sign -> GTE .)
    NOT             reduce using rule 70 (sign -> GTE .)
    IDENTIFIER      reduce using rule 70 (sign -> GTE .)
    REAL            reduce using rule 70 (sign -> GTE .)
    INTEGER         reduce using rule 70 (sign -> GTE .)
    CHAR            reduce using rule 70 (sign -> GTE .)
    STRING          reduce using rule 70 (sign -> GTE .)
    LPAREN          reduce using rule 70 (sign -> GTE .)


state 104

    (72) element -> NOT element .

    PLUS            reduce using rule 72 (element -> NOT element .)
    MINUS           reduce using rule 72 (element -> NOT element .)
    INT_DIV         reduce using rule 72 (element -> NOT element .)
    FLOAT_DIV       reduce using rule 72 (element -> NOT element .)
    MULTIPLY        reduce using rule 72 (element -> NOT element .)
    MOD             reduce using rule 72 (element -> NOT element .)
    EQ              reduce using rule 72 (element -> NOT element .)
    NEQ             reduce using rule 72 (element -> NOT element .)
    LT              reduce using rule 72 (element -> NOT element .)
    GT              reduce using rule 72 (element -> NOT element .)
    LTE             reduce using rule 72 (element -> NOT element .)
    GTE             reduce using rule 72 (element -> NOT element .)
    THEN            reduce using rule 72 (element -> NOT element .)
    AND             reduce using rule 72 (element -> NOT element .)
    OR              reduce using rule 72 (element -> NOT element .)
    DO              reduce using rule 72 (element -> NOT element .)
    SEMICOLON       reduce using rule 72 (element -> NOT element .)
    UNTIL           reduce using rule 72 (element -> NOT element .)
    TO              reduce using rule 72 (element -> NOT element .)
    DOWNTO          reduce using rule 72 (element -> NOT element .)
    ELSE            reduce using rule 72 (element -> NOT element .)
    RPAREN          reduce using rule 72 (element -> NOT element .)
    COMMA           reduce using rule 72 (element -> NOT element .)


state 105

    (80) function_call -> IDENTIFIER LPAREN . variables_list RPAREN
    (43) variables_list -> . variables_list COMMA variable
    (44) variables_list -> . variable
    (45) variable -> . expression
    (53) expression -> . expression and_or expression_m
    (54) expression -> . expression_m
    (55) expression_m -> . element
    (56) expression_m -> . expression_m sign element
    (71) element -> . BOOLEAN
    (72) element -> . NOT element
    (73) element -> . IDENTIFIER
    (74) element -> . REAL
    (75) element -> . INTEGER
    (76) element -> . CHAR
    (77) element -> . STRING
    (78) element -> . LPAREN expression RPAREN
    (79) element -> . function_call
    (80) function_call -> . IDENTIFIER LPAREN variables_list RPAREN

    BOOLEAN         shift and go to state 62
    NOT             shift and go to state 63
    IDENTIFIER      shift and go to state 64
    REAL            shift and go to state 65
    INTEGER         shift and go to state 66
    CHAR            shift and go to state 67
    STRING          shift and go to state 68
    LPAREN          shift and go to state 69

    variables_list                 shift and go to state 122
    variable                       shift and go to state 85
    expression                     shift and go to state 86
    expression_m                   shift and go to state 60
    element                        shift and go to state 61
    function_call                  shift and go to state 70

state 106

    (78) element -> LPAREN expression . RPAREN
    (53) expression -> expression . and_or expression_m
    (57) and_or -> . AND
    (58) and_or -> . OR

    RPAREN          shift and go to state 123
    AND             shift and go to state 89
    OR              shift and go to state 90

    and_or                         shift and go to state 88

state 107

    (49) while_statement -> WHILE expression DO . statement
    (33) statement -> . assignment_statement
    (34) statement -> . compound_statement
    (35) statement -> . if_statement
    (36) statement -> . while_statement
    (37) statement -> . repeat_statement
    (38) statement -> . for_statement
    (39) statement -> . procedure_or_function_call
    (40) statement -> . empty
    (46) assignment_statement -> . IDENTIFIER ASSIGNMENT expression
    (30) compound_statement -> . BEGIN statement_sequence END
    (47) if_statement -> . IF expression THEN statement
    (48) if_statement -> . IF expression THEN statement ELSE statement
    (49) while_statement -> . WHILE expression DO statement
    (50) repeat_statement -> . REPEAT statement UNTIL expression
    (51) for_statement -> . FOR assignment_statement TO expression DO statement
    (52) for_statement -> . FOR assignment_statement DOWNTO expression DO statement
    (41) procedure_or_function_call -> . IDENTIFIER
    (42) procedure_or_function_call -> . IDENTIFIER LPAREN variables_list RPAREN
    (1) empty -> .

    IDENTIFIER      shift and go to state 36
    BEGIN           shift and go to state 14
    IF              shift and go to state 37
    WHILE           shift and go to state 38
    REPEAT          shift and go to state 39
    FOR             shift and go to state 40
    ELSE            reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    UNTIL           reduce using rule 1 (empty -> .)

    statement                      shift and go to state 124
    assignment_statement           shift and go to state 28
    compound_statement             shift and go to state 29
    if_statement                   shift and go to state 30
    while_statement                shift and go to state 31
    repeat_statement               shift and go to state 32
    for_statement                  shift and go to state 33
    procedure_or_function_call     shift and go to state 34
    empty                          shift and go to state 35

state 108

    (50) repeat_statement -> REPEAT statement UNTIL . expression
    (53) expression -> . expression and_or expression_m
    (54) expression -> . expression_m
    (55) expression_m -> . element
    (56) expression_m -> . expression_m sign element
    (71) element -> . BOOLEAN
    (72) element -> . NOT element
    (73) element -> . IDENTIFIER
    (74) element -> . REAL
    (75) element -> . INTEGER
    (76) element -> . CHAR
    (77) element -> . STRING
    (78) element -> . LPAREN expression RPAREN
    (79) element -> . function_call
    (80) function_call -> . IDENTIFIER LPAREN variables_list RPAREN

    BOOLEAN         shift and go to state 62
    NOT             shift and go to state 63
    IDENTIFIER      shift and go to state 64
    REAL            shift and go to state 65
    INTEGER         shift and go to state 66
    CHAR            shift and go to state 67
    STRING          shift and go to state 68
    LPAREN          shift and go to state 69

    expression                     shift and go to state 125
    expression_m                   shift and go to state 60
    element                        shift and go to state 61
    function_call                  shift and go to state 70

state 109

    (51) for_statement -> FOR assignment_statement TO . expression DO statement
    (53) expression -> . expression and_or expression_m
    (54) expression -> . expression_m
    (55) expression_m -> . element
    (56) expression_m -> . expression_m sign element
    (71) element -> . BOOLEAN
    (72) element -> . NOT element
    (73) element -> . IDENTIFIER
    (74) element -> . REAL
    (75) element -> . INTEGER
    (76) element -> . CHAR
    (77) element -> . STRING
    (78) element -> . LPAREN expression RPAREN
    (79) element -> . function_call
    (80) function_call -> . IDENTIFIER LPAREN variables_list RPAREN

    BOOLEAN         shift and go to state 62
    NOT             shift and go to state 63
    IDENTIFIER      shift and go to state 64
    REAL            shift and go to state 65
    INTEGER         shift and go to state 66
    CHAR            shift and go to state 67
    STRING          shift and go to state 68
    LPAREN          shift and go to state 69

    expression                     shift and go to state 126
    expression_m                   shift and go to state 60
    element                        shift and go to state 61
    function_call                  shift and go to state 70

state 110

    (52) for_statement -> FOR assignment_statement DOWNTO . expression DO statement
    (53) expression -> . expression and_or expression_m
    (54) expression -> . expression_m
    (55) expression_m -> . element
    (56) expression_m -> . expression_m sign element
    (71) element -> . BOOLEAN
    (72) element -> . NOT element
    (73) element -> . IDENTIFIER
    (74) element -> . REAL
    (75) element -> . INTEGER
    (76) element -> . CHAR
    (77) element -> . STRING
    (78) element -> . LPAREN expression RPAREN
    (79) element -> . function_call
    (80) function_call -> . IDENTIFIER LPAREN variables_list RPAREN

    BOOLEAN         shift and go to state 62
    NOT             shift and go to state 63
    IDENTIFIER      shift and go to state 64
    REAL            shift and go to state 65
    INTEGER         shift and go to state 66
    CHAR            shift and go to state 67
    STRING          shift and go to state 68
    LPAREN          shift and go to state 69

    expression                     shift and go to state 127
    expression_m                   shift and go to state 60
    element                        shift and go to state 61
    function_call                  shift and go to state 70

state 111

    (26) parameter -> IDENTIFIER . COLON type

    COLON           shift and go to state 128


state 112

    (29) procedure_heading -> PROCEDURE IDENTIFIER LPAREN parameters_list . RPAREN

    RPAREN          shift and go to state 129


state 113

    (24) parameters_list -> parameter . COMMA parameters_list
    (25) parameters_list -> parameter .

    COMMA           shift and go to state 130
    RPAREN          reduce using rule 25 (parameters_list -> parameter .)


state 114

    (22) function_heading -> FUNCTION IDENTIFIER COLON type .

    SEMICOLON       reduce using rule 22 (function_heading -> FUNCTION IDENTIFIER COLON type .)


state 115

    (23) function_heading -> FUNCTION IDENTIFIER LPAREN parameters_list . RPAREN COLON type

    RPAREN          shift and go to state 131


state 116

    (10) variable_declaration -> IDENTIFIER COLON type SEMICOLON .

    IDENTIFIER      reduce using rule 10 (variable_declaration -> IDENTIFIER COLON type SEMICOLON .)
    BEGIN           reduce using rule 10 (variable_declaration -> IDENTIFIER COLON type SEMICOLON .)
    PROCEDURE       reduce using rule 10 (variable_declaration -> IDENTIFIER COLON type SEMICOLON .)
    FUNCTION        reduce using rule 10 (variable_declaration -> IDENTIFIER COLON type SEMICOLON .)


state 117

    (42) procedure_or_function_call -> IDENTIFIER LPAREN variables_list RPAREN .

    SEMICOLON       reduce using rule 42 (procedure_or_function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    UNTIL           reduce using rule 42 (procedure_or_function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    ELSE            reduce using rule 42 (procedure_or_function_call -> IDENTIFIER LPAREN variables_list RPAREN .)


state 118

    (43) variables_list -> variables_list COMMA . variable
    (45) variable -> . expression
    (53) expression -> . expression and_or expression_m
    (54) expression -> . expression_m
    (55) expression_m -> . element
    (56) expression_m -> . expression_m sign element
    (71) element -> . BOOLEAN
    (72) element -> . NOT element
    (73) element -> . IDENTIFIER
    (74) element -> . REAL
    (75) element -> . INTEGER
    (76) element -> . CHAR
    (77) element -> . STRING
    (78) element -> . LPAREN expression RPAREN
    (79) element -> . function_call
    (80) function_call -> . IDENTIFIER LPAREN variables_list RPAREN

    BOOLEAN         shift and go to state 62
    NOT             shift and go to state 63
    IDENTIFIER      shift and go to state 64
    REAL            shift and go to state 65
    INTEGER         shift and go to state 66
    CHAR            shift and go to state 67
    STRING          shift and go to state 68
    LPAREN          shift and go to state 69

    variable                       shift and go to state 132
    expression                     shift and go to state 86
    expression_m                   shift and go to state 60
    element                        shift and go to state 61
    function_call                  shift and go to state 70

state 119

    (47) if_statement -> IF expression THEN statement .
    (48) if_statement -> IF expression THEN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    SEMICOLON       reduce using rule 47 (if_statement -> IF expression THEN statement .)
    UNTIL           reduce using rule 47 (if_statement -> IF expression THEN statement .)
    ELSE            shift and go to state 133

  ! ELSE            [ reduce using rule 47 (if_statement -> IF expression THEN statement .) ]


state 120

    (53) expression -> expression and_or expression_m .
    (56) expression_m -> expression_m . sign element
    (59) sign -> . PLUS
    (60) sign -> . MINUS
    (61) sign -> . INT_DIV
    (62) sign -> . FLOAT_DIV
    (63) sign -> . MULTIPLY
    (64) sign -> . MOD
    (65) sign -> . EQ
    (66) sign -> . NEQ
    (67) sign -> . LT
    (68) sign -> . GT
    (69) sign -> . LTE
    (70) sign -> . GTE

    THEN            reduce using rule 53 (expression -> expression and_or expression_m .)
    AND             reduce using rule 53 (expression -> expression and_or expression_m .)
    OR              reduce using rule 53 (expression -> expression and_or expression_m .)
    DO              reduce using rule 53 (expression -> expression and_or expression_m .)
    SEMICOLON       reduce using rule 53 (expression -> expression and_or expression_m .)
    UNTIL           reduce using rule 53 (expression -> expression and_or expression_m .)
    TO              reduce using rule 53 (expression -> expression and_or expression_m .)
    DOWNTO          reduce using rule 53 (expression -> expression and_or expression_m .)
    ELSE            reduce using rule 53 (expression -> expression and_or expression_m .)
    RPAREN          reduce using rule 53 (expression -> expression and_or expression_m .)
    COMMA           reduce using rule 53 (expression -> expression and_or expression_m .)
    PLUS            shift and go to state 92
    MINUS           shift and go to state 93
    INT_DIV         shift and go to state 94
    FLOAT_DIV       shift and go to state 95
    MULTIPLY        shift and go to state 96
    MOD             shift and go to state 97
    EQ              shift and go to state 98
    NEQ             shift and go to state 99
    LT              shift and go to state 100
    GT              shift and go to state 101
    LTE             shift and go to state 102
    GTE             shift and go to state 103

    sign                           shift and go to state 91

state 121

    (56) expression_m -> expression_m sign element .

    PLUS            reduce using rule 56 (expression_m -> expression_m sign element .)
    MINUS           reduce using rule 56 (expression_m -> expression_m sign element .)
    INT_DIV         reduce using rule 56 (expression_m -> expression_m sign element .)
    FLOAT_DIV       reduce using rule 56 (expression_m -> expression_m sign element .)
    MULTIPLY        reduce using rule 56 (expression_m -> expression_m sign element .)
    MOD             reduce using rule 56 (expression_m -> expression_m sign element .)
    EQ              reduce using rule 56 (expression_m -> expression_m sign element .)
    NEQ             reduce using rule 56 (expression_m -> expression_m sign element .)
    LT              reduce using rule 56 (expression_m -> expression_m sign element .)
    GT              reduce using rule 56 (expression_m -> expression_m sign element .)
    LTE             reduce using rule 56 (expression_m -> expression_m sign element .)
    GTE             reduce using rule 56 (expression_m -> expression_m sign element .)
    THEN            reduce using rule 56 (expression_m -> expression_m sign element .)
    AND             reduce using rule 56 (expression_m -> expression_m sign element .)
    OR              reduce using rule 56 (expression_m -> expression_m sign element .)
    DO              reduce using rule 56 (expression_m -> expression_m sign element .)
    SEMICOLON       reduce using rule 56 (expression_m -> expression_m sign element .)
    UNTIL           reduce using rule 56 (expression_m -> expression_m sign element .)
    TO              reduce using rule 56 (expression_m -> expression_m sign element .)
    DOWNTO          reduce using rule 56 (expression_m -> expression_m sign element .)
    ELSE            reduce using rule 56 (expression_m -> expression_m sign element .)
    RPAREN          reduce using rule 56 (expression_m -> expression_m sign element .)
    COMMA           reduce using rule 56 (expression_m -> expression_m sign element .)


state 122

    (80) function_call -> IDENTIFIER LPAREN variables_list . RPAREN
    (43) variables_list -> variables_list . COMMA variable

    RPAREN          shift and go to state 134
    COMMA           shift and go to state 118


state 123

    (78) element -> LPAREN expression RPAREN .

    PLUS            reduce using rule 78 (element -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 78 (element -> LPAREN expression RPAREN .)
    INT_DIV         reduce using rule 78 (element -> LPAREN expression RPAREN .)
    FLOAT_DIV       reduce using rule 78 (element -> LPAREN expression RPAREN .)
    MULTIPLY        reduce using rule 78 (element -> LPAREN expression RPAREN .)
    MOD             reduce using rule 78 (element -> LPAREN expression RPAREN .)
    EQ              reduce using rule 78 (element -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 78 (element -> LPAREN expression RPAREN .)
    LT              reduce using rule 78 (element -> LPAREN expression RPAREN .)
    GT              reduce using rule 78 (element -> LPAREN expression RPAREN .)
    LTE             reduce using rule 78 (element -> LPAREN expression RPAREN .)
    GTE             reduce using rule 78 (element -> LPAREN expression RPAREN .)
    THEN            reduce using rule 78 (element -> LPAREN expression RPAREN .)
    AND             reduce using rule 78 (element -> LPAREN expression RPAREN .)
    OR              reduce using rule 78 (element -> LPAREN expression RPAREN .)
    DO              reduce using rule 78 (element -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 78 (element -> LPAREN expression RPAREN .)
    UNTIL           reduce using rule 78 (element -> LPAREN expression RPAREN .)
    TO              reduce using rule 78 (element -> LPAREN expression RPAREN .)
    DOWNTO          reduce using rule 78 (element -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 78 (element -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 78 (element -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 78 (element -> LPAREN expression RPAREN .)


state 124

    (49) while_statement -> WHILE expression DO statement .

    SEMICOLON       reduce using rule 49 (while_statement -> WHILE expression DO statement .)
    UNTIL           reduce using rule 49 (while_statement -> WHILE expression DO statement .)
    ELSE            reduce using rule 49 (while_statement -> WHILE expression DO statement .)


state 125

    (50) repeat_statement -> REPEAT statement UNTIL expression .
    (53) expression -> expression . and_or expression_m
    (57) and_or -> . AND
    (58) and_or -> . OR

    SEMICOLON       reduce using rule 50 (repeat_statement -> REPEAT statement UNTIL expression .)
    UNTIL           reduce using rule 50 (repeat_statement -> REPEAT statement UNTIL expression .)
    ELSE            reduce using rule 50 (repeat_statement -> REPEAT statement UNTIL expression .)
    AND             shift and go to state 89
    OR              shift and go to state 90

    and_or                         shift and go to state 88

state 126

    (51) for_statement -> FOR assignment_statement TO expression . DO statement
    (53) expression -> expression . and_or expression_m
    (57) and_or -> . AND
    (58) and_or -> . OR

    DO              shift and go to state 135
    AND             shift and go to state 89
    OR              shift and go to state 90

    and_or                         shift and go to state 88

state 127

    (52) for_statement -> FOR assignment_statement DOWNTO expression . DO statement
    (53) expression -> expression . and_or expression_m
    (57) and_or -> . AND
    (58) and_or -> . OR

    DO              shift and go to state 136
    AND             shift and go to state 89
    OR              shift and go to state 90

    and_or                         shift and go to state 88

state 128

    (26) parameter -> IDENTIFIER COLON . type
    (11) type -> . SINTEGER
    (12) type -> . SCHAR
    (13) type -> . SREAL
    (14) type -> . SSTRING
    (15) type -> . SBOOLEAN

    SINTEGER        shift and go to state 46
    SCHAR           shift and go to state 47
    SREAL           shift and go to state 48
    SSTRING         shift and go to state 49
    SBOOLEAN        shift and go to state 50

    type                           shift and go to state 137

state 129

    (29) procedure_heading -> PROCEDURE IDENTIFIER LPAREN parameters_list RPAREN .

    SEMICOLON       reduce using rule 29 (procedure_heading -> PROCEDURE IDENTIFIER LPAREN parameters_list RPAREN .)


state 130

    (24) parameters_list -> parameter COMMA . parameters_list
    (24) parameters_list -> . parameter COMMA parameters_list
    (25) parameters_list -> . parameter
    (26) parameter -> . IDENTIFIER COLON type

    IDENTIFIER      shift and go to state 111

    parameter                      shift and go to state 113
    parameters_list                shift and go to state 138

state 131

    (23) function_heading -> FUNCTION IDENTIFIER LPAREN parameters_list RPAREN . COLON type

    COLON           shift and go to state 139


state 132

    (43) variables_list -> variables_list COMMA variable .

    RPAREN          reduce using rule 43 (variables_list -> variables_list COMMA variable .)
    COMMA           reduce using rule 43 (variables_list -> variables_list COMMA variable .)


state 133

    (48) if_statement -> IF expression THEN statement ELSE . statement
    (33) statement -> . assignment_statement
    (34) statement -> . compound_statement
    (35) statement -> . if_statement
    (36) statement -> . while_statement
    (37) statement -> . repeat_statement
    (38) statement -> . for_statement
    (39) statement -> . procedure_or_function_call
    (40) statement -> . empty
    (46) assignment_statement -> . IDENTIFIER ASSIGNMENT expression
    (30) compound_statement -> . BEGIN statement_sequence END
    (47) if_statement -> . IF expression THEN statement
    (48) if_statement -> . IF expression THEN statement ELSE statement
    (49) while_statement -> . WHILE expression DO statement
    (50) repeat_statement -> . REPEAT statement UNTIL expression
    (51) for_statement -> . FOR assignment_statement TO expression DO statement
    (52) for_statement -> . FOR assignment_statement DOWNTO expression DO statement
    (41) procedure_or_function_call -> . IDENTIFIER
    (42) procedure_or_function_call -> . IDENTIFIER LPAREN variables_list RPAREN
    (1) empty -> .

    IDENTIFIER      shift and go to state 36
    BEGIN           shift and go to state 14
    IF              shift and go to state 37
    WHILE           shift and go to state 38
    REPEAT          shift and go to state 39
    FOR             shift and go to state 40
    ELSE            reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    UNTIL           reduce using rule 1 (empty -> .)

    statement                      shift and go to state 140
    assignment_statement           shift and go to state 28
    compound_statement             shift and go to state 29
    if_statement                   shift and go to state 30
    while_statement                shift and go to state 31
    repeat_statement               shift and go to state 32
    for_statement                  shift and go to state 33
    procedure_or_function_call     shift and go to state 34
    empty                          shift and go to state 35

state 134

    (80) function_call -> IDENTIFIER LPAREN variables_list RPAREN .

    PLUS            reduce using rule 80 (function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    MINUS           reduce using rule 80 (function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    INT_DIV         reduce using rule 80 (function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    FLOAT_DIV       reduce using rule 80 (function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    MULTIPLY        reduce using rule 80 (function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    MOD             reduce using rule 80 (function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    EQ              reduce using rule 80 (function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    NEQ             reduce using rule 80 (function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    LT              reduce using rule 80 (function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    GT              reduce using rule 80 (function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    LTE             reduce using rule 80 (function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    GTE             reduce using rule 80 (function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    THEN            reduce using rule 80 (function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    AND             reduce using rule 80 (function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    OR              reduce using rule 80 (function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    DO              reduce using rule 80 (function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    SEMICOLON       reduce using rule 80 (function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    UNTIL           reduce using rule 80 (function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    TO              reduce using rule 80 (function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    DOWNTO          reduce using rule 80 (function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    ELSE            reduce using rule 80 (function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    RPAREN          reduce using rule 80 (function_call -> IDENTIFIER LPAREN variables_list RPAREN .)
    COMMA           reduce using rule 80 (function_call -> IDENTIFIER LPAREN variables_list RPAREN .)


state 135

    (51) for_statement -> FOR assignment_statement TO expression DO . statement
    (33) statement -> . assignment_statement
    (34) statement -> . compound_statement
    (35) statement -> . if_statement
    (36) statement -> . while_statement
    (37) statement -> . repeat_statement
    (38) statement -> . for_statement
    (39) statement -> . procedure_or_function_call
    (40) statement -> . empty
    (46) assignment_statement -> . IDENTIFIER ASSIGNMENT expression
    (30) compound_statement -> . BEGIN statement_sequence END
    (47) if_statement -> . IF expression THEN statement
    (48) if_statement -> . IF expression THEN statement ELSE statement
    (49) while_statement -> . WHILE expression DO statement
    (50) repeat_statement -> . REPEAT statement UNTIL expression
    (51) for_statement -> . FOR assignment_statement TO expression DO statement
    (52) for_statement -> . FOR assignment_statement DOWNTO expression DO statement
    (41) procedure_or_function_call -> . IDENTIFIER
    (42) procedure_or_function_call -> . IDENTIFIER LPAREN variables_list RPAREN
    (1) empty -> .

    IDENTIFIER      shift and go to state 36
    BEGIN           shift and go to state 14
    IF              shift and go to state 37
    WHILE           shift and go to state 38
    REPEAT          shift and go to state 39
    FOR             shift and go to state 40
    ELSE            reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    UNTIL           reduce using rule 1 (empty -> .)

    assignment_statement           shift and go to state 28
    statement                      shift and go to state 141
    compound_statement             shift and go to state 29
    if_statement                   shift and go to state 30
    while_statement                shift and go to state 31
    repeat_statement               shift and go to state 32
    for_statement                  shift and go to state 33
    procedure_or_function_call     shift and go to state 34
    empty                          shift and go to state 35

state 136

    (52) for_statement -> FOR assignment_statement DOWNTO expression DO . statement
    (33) statement -> . assignment_statement
    (34) statement -> . compound_statement
    (35) statement -> . if_statement
    (36) statement -> . while_statement
    (37) statement -> . repeat_statement
    (38) statement -> . for_statement
    (39) statement -> . procedure_or_function_call
    (40) statement -> . empty
    (46) assignment_statement -> . IDENTIFIER ASSIGNMENT expression
    (30) compound_statement -> . BEGIN statement_sequence END
    (47) if_statement -> . IF expression THEN statement
    (48) if_statement -> . IF expression THEN statement ELSE statement
    (49) while_statement -> . WHILE expression DO statement
    (50) repeat_statement -> . REPEAT statement UNTIL expression
    (51) for_statement -> . FOR assignment_statement TO expression DO statement
    (52) for_statement -> . FOR assignment_statement DOWNTO expression DO statement
    (41) procedure_or_function_call -> . IDENTIFIER
    (42) procedure_or_function_call -> . IDENTIFIER LPAREN variables_list RPAREN
    (1) empty -> .

    IDENTIFIER      shift and go to state 36
    BEGIN           shift and go to state 14
    IF              shift and go to state 37
    WHILE           shift and go to state 38
    REPEAT          shift and go to state 39
    FOR             shift and go to state 40
    ELSE            reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    UNTIL           reduce using rule 1 (empty -> .)

    assignment_statement           shift and go to state 28
    statement                      shift and go to state 142
    compound_statement             shift and go to state 29
    if_statement                   shift and go to state 30
    while_statement                shift and go to state 31
    repeat_statement               shift and go to state 32
    for_statement                  shift and go to state 33
    procedure_or_function_call     shift and go to state 34
    empty                          shift and go to state 35

state 137

    (26) parameter -> IDENTIFIER COLON type .

    COMMA           reduce using rule 26 (parameter -> IDENTIFIER COLON type .)
    RPAREN          reduce using rule 26 (parameter -> IDENTIFIER COLON type .)


state 138

    (24) parameters_list -> parameter COMMA parameters_list .

    RPAREN          reduce using rule 24 (parameters_list -> parameter COMMA parameters_list .)


state 139

    (23) function_heading -> FUNCTION IDENTIFIER LPAREN parameters_list RPAREN COLON . type
    (11) type -> . SINTEGER
    (12) type -> . SCHAR
    (13) type -> . SREAL
    (14) type -> . SSTRING
    (15) type -> . SBOOLEAN

    SINTEGER        shift and go to state 46
    SCHAR           shift and go to state 47
    SREAL           shift and go to state 48
    SSTRING         shift and go to state 49
    SBOOLEAN        shift and go to state 50

    type                           shift and go to state 143

state 140

    (48) if_statement -> IF expression THEN statement ELSE statement .

    SEMICOLON       reduce using rule 48 (if_statement -> IF expression THEN statement ELSE statement .)
    UNTIL           reduce using rule 48 (if_statement -> IF expression THEN statement ELSE statement .)
    ELSE            reduce using rule 48 (if_statement -> IF expression THEN statement ELSE statement .)


state 141

    (51) for_statement -> FOR assignment_statement TO expression DO statement .

    SEMICOLON       reduce using rule 51 (for_statement -> FOR assignment_statement TO expression DO statement .)
    UNTIL           reduce using rule 51 (for_statement -> FOR assignment_statement TO expression DO statement .)
    ELSE            reduce using rule 51 (for_statement -> FOR assignment_statement TO expression DO statement .)


state 142

    (52) for_statement -> FOR assignment_statement DOWNTO expression DO statement .

    SEMICOLON       reduce using rule 52 (for_statement -> FOR assignment_statement DOWNTO expression DO statement .)
    UNTIL           reduce using rule 52 (for_statement -> FOR assignment_statement DOWNTO expression DO statement .)
    ELSE            reduce using rule 52 (for_statement -> FOR assignment_statement DOWNTO expression DO statement .)


state 143

    (23) function_heading -> FUNCTION IDENTIFIER LPAREN parameters_list RPAREN COLON type .

    SEMICOLON       reduce using rule 23 (function_heading -> FUNCTION IDENTIFIER LPAREN parameters_list RPAREN COLON type .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for BEGIN in state 6 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 119 resolved as shift
