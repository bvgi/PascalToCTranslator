Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     program -> PROGRAM identifier SEMICOLON variable_declaration_part procedure_or_function compound_statement DOT
Rule 3     block -> variable_declaration_part procedure_or_function compound_statement
Rule 4     variable_declaration_part -> empty
Rule 5     variable_declaration_part -> VAR variable_declaration_list
Rule 6     variable_declaration_list -> variable_declaration
Rule 7     variable_declaration_list -> variable_declaration variable_declaration_list
Rule 8     variable_declaration -> identifier COLON type SEMICOLON
Rule 9     type -> SINTEGER
Rule 10    type -> SCHAR
Rule 11    type -> SREAL
Rule 12    type -> SSTRING
Rule 13    type -> SBOOLEAN
Rule 14    procedure_or_function -> proc_or_func_declaration SEMICOLON procedure_or_function
Rule 15    procedure_or_function -> empty
Rule 16    proc_or_func_declaration -> procedure_declaration
Rule 17    proc_or_func_declaration -> function_declaration
Rule 18    function_declaration -> function_heading SEMICOLON block
Rule 19    function_heading -> FUNCTION identifier COLON type
Rule 20    function_heading -> FUNCTION identifier LPAREN parameters_list RPAREN COLON type
Rule 21    parameters_list -> parameter COMMA parameters_list
Rule 22    parameters_list -> parameter
Rule 23    parameter -> identifier COLON type
Rule 24    procedure_declaration -> procedure_heading SEMICOLON block
Rule 25    procedure_heading -> PROCEDURE identifier
Rule 26    procedure_heading -> PROCEDURE identifier LPAREN parameters_list RPAREN
Rule 27    compound_statement -> BEGIN statement_sequence END
Rule 28    statement_sequence -> statement SEMICOLON statement_sequence
Rule 29    statement_sequence -> statement SEMICOLON
Rule 30    statement -> compound_statement
Rule 31    statement -> assignment_statement
Rule 32    statement -> if_statement
Rule 33    statement -> while_statement
Rule 34    statement -> repeat_statement
Rule 35    statement -> for_statement
Rule 36    statement -> procedure_or_function_call
Rule 37    procedure_or_function_call -> identifier
Rule 38    procedure_or_function_call -> identifier LPAREN variables_list RPAREN
Rule 39    variables_list -> variables_list COMMA expression
Rule 40    variables_list -> expression
Rule 41    assignment_statement -> identifier ASSIGNMENT expression
Rule 42    if_statement -> IF expression THEN compound_statement
Rule 43    if_statement -> IF expression THEN compound_statement ELSE compound_statement
Rule 44    while_statement -> WHILE expression DO statement
Rule 45    repeat_statement -> REPEAT statement_sequence UNTIL expression
Rule 46    for_statement -> FOR assignment_statement TO expression DO statement
Rule 47    for_statement -> FOR assignment_statement DOWNTO expression DO statement
Rule 48    expression -> expression and_or expression_m
Rule 49    expression -> expression_m
Rule 50    expression_m -> element
Rule 51    expression_m -> expression_m sign element
Rule 52    and_or -> AND
Rule 53    and_or -> OR
Rule 54    sign -> PLUS
Rule 55    sign -> MINUS
Rule 56    sign -> INT_DIV
Rule 57    sign -> FLOAT_DIV
Rule 58    sign -> MULTIPLY
Rule 59    sign -> MOD
Rule 60    sign -> EQ
Rule 61    sign -> NEQ
Rule 62    sign -> LT
Rule 63    sign -> GT
Rule 64    sign -> LTE
Rule 65    sign -> GTE
Rule 66    element -> BOOLEAN
Rule 67    element -> NOT element
Rule 68    element -> identifier
Rule 69    element -> real
Rule 70    element -> integer
Rule 71    element -> char
Rule 72    element -> string
Rule 73    element -> LPAREN expression RPAREN
Rule 74    element -> function_call
Rule 75    element -> empty
Rule 76    function_call -> identifier LPAREN variables_list RPAREN
Rule 77    identifier -> IDENTIFIER
Rule 78    real -> REAL
Rule 79    integer -> INTEGER
Rule 80    string -> STRING
Rule 81    char -> CHAR

Terminals, with rules where they appear

AND                  : 52
ASSIGNMENT           : 41
BEGIN                : 27
BOOLEAN              : 66
CHAR                 : 81
COLON                : 8 19 20 23
COMMA                : 21 39
DO                   : 44 46 47
DOT                  : 2
DOWNTO               : 47
ELSE                 : 43
END                  : 27
EQ                   : 60
FLOAT_DIV            : 57
FOR                  : 46 47
FUNCTION             : 19 20
GT                   : 63
GTE                  : 65
IDENTIFIER           : 77
IF                   : 42 43
INTEGER              : 79
INT_DIV              : 56
LPAREN               : 20 26 38 73 76
LT                   : 62
LTE                  : 64
MINUS                : 55
MOD                  : 59
MULTIPLY             : 58
NEQ                  : 61
NOT                  : 67
OR                   : 53
PLUS                 : 54
PROCEDURE            : 25 26
PROGRAM              : 2
REAL                 : 78
REPEAT               : 45
RPAREN               : 20 26 38 73 76
SBOOLEAN             : 13
SCHAR                : 10
SEMICOLON            : 2 8 14 18 24 28 29
SINTEGER             : 9
SREAL                : 11
SSTRING              : 12
STRING               : 80
THEN                 : 42 43
TO                   : 46
UNTIL                : 45
VAR                  : 5
WHILE                : 44
error                : 

Nonterminals, with rules where they appear

and_or               : 48
assignment_statement : 31 46 47
block                : 18 24
char                 : 71
compound_statement   : 2 3 30 42 43 43
element              : 50 51 67
empty                : 4 15 75
expression           : 39 40 41 42 43 44 45 46 47 48 73
expression_m         : 48 49 51
for_statement        : 35
function_call        : 74
function_declaration : 17
function_heading     : 18
identifier           : 2 8 19 20 23 25 26 37 38 41 68 76
if_statement         : 32
integer              : 70
parameter            : 21 22
parameters_list      : 20 21 26
proc_or_func_declaration : 14
procedure_declaration : 16
procedure_heading    : 24
procedure_or_function : 2 3 14
procedure_or_function_call : 36
program              : 0
real                 : 69
repeat_statement     : 34
sign                 : 51
statement            : 28 29 44 46 47
statement_sequence   : 27 28 45
string               : 72
type                 : 8 19 20 23
variable_declaration : 6 7
variable_declaration_list : 5 7
variable_declaration_part : 2 3
variables_list       : 38 39 76
while_statement      : 33

Parsing method: LALR

state 0

    (0) S' -> . program
    (2) program -> . PROGRAM identifier SEMICOLON variable_declaration_part procedure_or_function compound_statement DOT

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (2) program -> PROGRAM . identifier SEMICOLON variable_declaration_part procedure_or_function compound_statement DOT
    (77) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    identifier                     shift and go to state 3

state 3

    (2) program -> PROGRAM identifier . SEMICOLON variable_declaration_part procedure_or_function compound_statement DOT

    SEMICOLON       shift and go to state 5


state 4

    (77) identifier -> IDENTIFIER .

    SEMICOLON       reduce using rule 77 (identifier -> IDENTIFIER .)
    COLON           reduce using rule 77 (identifier -> IDENTIFIER .)
    LPAREN          reduce using rule 77 (identifier -> IDENTIFIER .)
    ASSIGNMENT      reduce using rule 77 (identifier -> IDENTIFIER .)
    PLUS            reduce using rule 77 (identifier -> IDENTIFIER .)
    MINUS           reduce using rule 77 (identifier -> IDENTIFIER .)
    INT_DIV         reduce using rule 77 (identifier -> IDENTIFIER .)
    FLOAT_DIV       reduce using rule 77 (identifier -> IDENTIFIER .)
    MULTIPLY        reduce using rule 77 (identifier -> IDENTIFIER .)
    MOD             reduce using rule 77 (identifier -> IDENTIFIER .)
    EQ              reduce using rule 77 (identifier -> IDENTIFIER .)
    NEQ             reduce using rule 77 (identifier -> IDENTIFIER .)
    LT              reduce using rule 77 (identifier -> IDENTIFIER .)
    GT              reduce using rule 77 (identifier -> IDENTIFIER .)
    LTE             reduce using rule 77 (identifier -> IDENTIFIER .)
    GTE             reduce using rule 77 (identifier -> IDENTIFIER .)
    THEN            reduce using rule 77 (identifier -> IDENTIFIER .)
    AND             reduce using rule 77 (identifier -> IDENTIFIER .)
    OR              reduce using rule 77 (identifier -> IDENTIFIER .)
    DO              reduce using rule 77 (identifier -> IDENTIFIER .)
    TO              reduce using rule 77 (identifier -> IDENTIFIER .)
    DOWNTO          reduce using rule 77 (identifier -> IDENTIFIER .)
    RPAREN          reduce using rule 77 (identifier -> IDENTIFIER .)
    COMMA           reduce using rule 77 (identifier -> IDENTIFIER .)


state 5

    (2) program -> PROGRAM identifier SEMICOLON . variable_declaration_part procedure_or_function compound_statement DOT
    (4) variable_declaration_part -> . empty
    (5) variable_declaration_part -> . VAR variable_declaration_list
    (1) empty -> .

    VAR             shift and go to state 8
    PROCEDURE       reduce using rule 1 (empty -> .)
    FUNCTION        reduce using rule 1 (empty -> .)
    BEGIN           reduce using rule 1 (empty -> .)

    variable_declaration_part      shift and go to state 6
    empty                          shift and go to state 7

state 6

    (2) program -> PROGRAM identifier SEMICOLON variable_declaration_part . procedure_or_function compound_statement DOT
    (14) procedure_or_function -> . proc_or_func_declaration SEMICOLON procedure_or_function
    (15) procedure_or_function -> . empty
    (16) proc_or_func_declaration -> . procedure_declaration
    (17) proc_or_func_declaration -> . function_declaration
    (1) empty -> .
    (24) procedure_declaration -> . procedure_heading SEMICOLON block
    (18) function_declaration -> . function_heading SEMICOLON block
    (25) procedure_heading -> . PROCEDURE identifier
    (26) procedure_heading -> . PROCEDURE identifier LPAREN parameters_list RPAREN
    (19) function_heading -> . FUNCTION identifier COLON type
    (20) function_heading -> . FUNCTION identifier LPAREN parameters_list RPAREN COLON type

    BEGIN           reduce using rule 1 (empty -> .)
    PROCEDURE       shift and go to state 16
    FUNCTION        shift and go to state 17

    procedure_or_function          shift and go to state 9
    proc_or_func_declaration       shift and go to state 10
    empty                          shift and go to state 11
    procedure_declaration          shift and go to state 12
    function_declaration           shift and go to state 13
    procedure_heading              shift and go to state 14
    function_heading               shift and go to state 15

state 7

    (4) variable_declaration_part -> empty .

    PROCEDURE       reduce using rule 4 (variable_declaration_part -> empty .)
    FUNCTION        reduce using rule 4 (variable_declaration_part -> empty .)
    BEGIN           reduce using rule 4 (variable_declaration_part -> empty .)


state 8

    (5) variable_declaration_part -> VAR . variable_declaration_list
    (6) variable_declaration_list -> . variable_declaration
    (7) variable_declaration_list -> . variable_declaration variable_declaration_list
    (8) variable_declaration -> . identifier COLON type SEMICOLON
    (77) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    variable_declaration_list      shift and go to state 18
    variable_declaration           shift and go to state 19
    identifier                     shift and go to state 20

state 9

    (2) program -> PROGRAM identifier SEMICOLON variable_declaration_part procedure_or_function . compound_statement DOT
    (27) compound_statement -> . BEGIN statement_sequence END

    BEGIN           shift and go to state 22

    compound_statement             shift and go to state 21

state 10

    (14) procedure_or_function -> proc_or_func_declaration . SEMICOLON procedure_or_function

    SEMICOLON       shift and go to state 23


state 11

    (15) procedure_or_function -> empty .

    BEGIN           reduce using rule 15 (procedure_or_function -> empty .)


state 12

    (16) proc_or_func_declaration -> procedure_declaration .

    SEMICOLON       reduce using rule 16 (proc_or_func_declaration -> procedure_declaration .)


state 13

    (17) proc_or_func_declaration -> function_declaration .

    SEMICOLON       reduce using rule 17 (proc_or_func_declaration -> function_declaration .)


state 14

    (24) procedure_declaration -> procedure_heading . SEMICOLON block

    SEMICOLON       shift and go to state 24


state 15

    (18) function_declaration -> function_heading . SEMICOLON block

    SEMICOLON       shift and go to state 25


state 16

    (25) procedure_heading -> PROCEDURE . identifier
    (26) procedure_heading -> PROCEDURE . identifier LPAREN parameters_list RPAREN
    (77) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    identifier                     shift and go to state 26

state 17

    (19) function_heading -> FUNCTION . identifier COLON type
    (20) function_heading -> FUNCTION . identifier LPAREN parameters_list RPAREN COLON type
    (77) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    identifier                     shift and go to state 27

state 18

    (5) variable_declaration_part -> VAR variable_declaration_list .

    PROCEDURE       reduce using rule 5 (variable_declaration_part -> VAR variable_declaration_list .)
    FUNCTION        reduce using rule 5 (variable_declaration_part -> VAR variable_declaration_list .)
    BEGIN           reduce using rule 5 (variable_declaration_part -> VAR variable_declaration_list .)


state 19

    (6) variable_declaration_list -> variable_declaration .
    (7) variable_declaration_list -> variable_declaration . variable_declaration_list
    (6) variable_declaration_list -> . variable_declaration
    (7) variable_declaration_list -> . variable_declaration variable_declaration_list
    (8) variable_declaration -> . identifier COLON type SEMICOLON
    (77) identifier -> . IDENTIFIER

    PROCEDURE       reduce using rule 6 (variable_declaration_list -> variable_declaration .)
    FUNCTION        reduce using rule 6 (variable_declaration_list -> variable_declaration .)
    BEGIN           reduce using rule 6 (variable_declaration_list -> variable_declaration .)
    IDENTIFIER      shift and go to state 4

    variable_declaration           shift and go to state 19
    variable_declaration_list      shift and go to state 28
    identifier                     shift and go to state 20

state 20

    (8) variable_declaration -> identifier . COLON type SEMICOLON

    COLON           shift and go to state 29


state 21

    (2) program -> PROGRAM identifier SEMICOLON variable_declaration_part procedure_or_function compound_statement . DOT

    DOT             shift and go to state 30


state 22

    (27) compound_statement -> BEGIN . statement_sequence END
    (28) statement_sequence -> . statement SEMICOLON statement_sequence
    (29) statement_sequence -> . statement SEMICOLON
    (30) statement -> . compound_statement
    (31) statement -> . assignment_statement
    (32) statement -> . if_statement
    (33) statement -> . while_statement
    (34) statement -> . repeat_statement
    (35) statement -> . for_statement
    (36) statement -> . procedure_or_function_call
    (27) compound_statement -> . BEGIN statement_sequence END
    (41) assignment_statement -> . identifier ASSIGNMENT expression
    (42) if_statement -> . IF expression THEN compound_statement
    (43) if_statement -> . IF expression THEN compound_statement ELSE compound_statement
    (44) while_statement -> . WHILE expression DO statement
    (45) repeat_statement -> . REPEAT statement_sequence UNTIL expression
    (46) for_statement -> . FOR assignment_statement TO expression DO statement
    (47) for_statement -> . FOR assignment_statement DOWNTO expression DO statement
    (37) procedure_or_function_call -> . identifier
    (38) procedure_or_function_call -> . identifier LPAREN variables_list RPAREN
    (77) identifier -> . IDENTIFIER

    BEGIN           shift and go to state 22
    IF              shift and go to state 41
    WHILE           shift and go to state 42
    REPEAT          shift and go to state 43
    FOR             shift and go to state 44
    IDENTIFIER      shift and go to state 4

    statement_sequence             shift and go to state 31
    statement                      shift and go to state 32
    compound_statement             shift and go to state 33
    assignment_statement           shift and go to state 34
    if_statement                   shift and go to state 35
    while_statement                shift and go to state 36
    repeat_statement               shift and go to state 37
    for_statement                  shift and go to state 38
    procedure_or_function_call     shift and go to state 39
    identifier                     shift and go to state 40

state 23

    (14) procedure_or_function -> proc_or_func_declaration SEMICOLON . procedure_or_function
    (14) procedure_or_function -> . proc_or_func_declaration SEMICOLON procedure_or_function
    (15) procedure_or_function -> . empty
    (16) proc_or_func_declaration -> . procedure_declaration
    (17) proc_or_func_declaration -> . function_declaration
    (1) empty -> .
    (24) procedure_declaration -> . procedure_heading SEMICOLON block
    (18) function_declaration -> . function_heading SEMICOLON block
    (25) procedure_heading -> . PROCEDURE identifier
    (26) procedure_heading -> . PROCEDURE identifier LPAREN parameters_list RPAREN
    (19) function_heading -> . FUNCTION identifier COLON type
    (20) function_heading -> . FUNCTION identifier LPAREN parameters_list RPAREN COLON type

    BEGIN           reduce using rule 1 (empty -> .)
    PROCEDURE       shift and go to state 16
    FUNCTION        shift and go to state 17

    proc_or_func_declaration       shift and go to state 10
    procedure_or_function          shift and go to state 45
    empty                          shift and go to state 11
    procedure_declaration          shift and go to state 12
    function_declaration           shift and go to state 13
    procedure_heading              shift and go to state 14
    function_heading               shift and go to state 15

state 24

    (24) procedure_declaration -> procedure_heading SEMICOLON . block
    (3) block -> . variable_declaration_part procedure_or_function compound_statement
    (4) variable_declaration_part -> . empty
    (5) variable_declaration_part -> . VAR variable_declaration_list
    (1) empty -> .

    VAR             shift and go to state 8
    PROCEDURE       reduce using rule 1 (empty -> .)
    FUNCTION        reduce using rule 1 (empty -> .)
    BEGIN           reduce using rule 1 (empty -> .)

    block                          shift and go to state 46
    variable_declaration_part      shift and go to state 47
    empty                          shift and go to state 7

state 25

    (18) function_declaration -> function_heading SEMICOLON . block
    (3) block -> . variable_declaration_part procedure_or_function compound_statement
    (4) variable_declaration_part -> . empty
    (5) variable_declaration_part -> . VAR variable_declaration_list
    (1) empty -> .

    VAR             shift and go to state 8
    PROCEDURE       reduce using rule 1 (empty -> .)
    FUNCTION        reduce using rule 1 (empty -> .)
    BEGIN           reduce using rule 1 (empty -> .)

    block                          shift and go to state 48
    variable_declaration_part      shift and go to state 47
    empty                          shift and go to state 7

state 26

    (25) procedure_heading -> PROCEDURE identifier .
    (26) procedure_heading -> PROCEDURE identifier . LPAREN parameters_list RPAREN

    SEMICOLON       reduce using rule 25 (procedure_heading -> PROCEDURE identifier .)
    LPAREN          shift and go to state 49


state 27

    (19) function_heading -> FUNCTION identifier . COLON type
    (20) function_heading -> FUNCTION identifier . LPAREN parameters_list RPAREN COLON type

    COLON           shift and go to state 50
    LPAREN          shift and go to state 51


state 28

    (7) variable_declaration_list -> variable_declaration variable_declaration_list .

    PROCEDURE       reduce using rule 7 (variable_declaration_list -> variable_declaration variable_declaration_list .)
    FUNCTION        reduce using rule 7 (variable_declaration_list -> variable_declaration variable_declaration_list .)
    BEGIN           reduce using rule 7 (variable_declaration_list -> variable_declaration variable_declaration_list .)


state 29

    (8) variable_declaration -> identifier COLON . type SEMICOLON
    (9) type -> . SINTEGER
    (10) type -> . SCHAR
    (11) type -> . SREAL
    (12) type -> . SSTRING
    (13) type -> . SBOOLEAN

    SINTEGER        shift and go to state 53
    SCHAR           shift and go to state 54
    SREAL           shift and go to state 55
    SSTRING         shift and go to state 56
    SBOOLEAN        shift and go to state 57

    type                           shift and go to state 52

state 30

    (2) program -> PROGRAM identifier SEMICOLON variable_declaration_part procedure_or_function compound_statement DOT .

    $end            reduce using rule 2 (program -> PROGRAM identifier SEMICOLON variable_declaration_part procedure_or_function compound_statement DOT .)


state 31

    (27) compound_statement -> BEGIN statement_sequence . END

    END             shift and go to state 58


state 32

    (28) statement_sequence -> statement . SEMICOLON statement_sequence
    (29) statement_sequence -> statement . SEMICOLON

    SEMICOLON       shift and go to state 59


state 33

    (30) statement -> compound_statement .

    SEMICOLON       reduce using rule 30 (statement -> compound_statement .)


state 34

    (31) statement -> assignment_statement .

    SEMICOLON       reduce using rule 31 (statement -> assignment_statement .)


state 35

    (32) statement -> if_statement .

    SEMICOLON       reduce using rule 32 (statement -> if_statement .)


state 36

    (33) statement -> while_statement .

    SEMICOLON       reduce using rule 33 (statement -> while_statement .)


state 37

    (34) statement -> repeat_statement .

    SEMICOLON       reduce using rule 34 (statement -> repeat_statement .)


state 38

    (35) statement -> for_statement .

    SEMICOLON       reduce using rule 35 (statement -> for_statement .)


state 39

    (36) statement -> procedure_or_function_call .

    SEMICOLON       reduce using rule 36 (statement -> procedure_or_function_call .)


state 40

    (41) assignment_statement -> identifier . ASSIGNMENT expression
    (37) procedure_or_function_call -> identifier .
    (38) procedure_or_function_call -> identifier . LPAREN variables_list RPAREN

    ASSIGNMENT      shift and go to state 60
    SEMICOLON       reduce using rule 37 (procedure_or_function_call -> identifier .)
    LPAREN          shift and go to state 61


state 41

    (42) if_statement -> IF . expression THEN compound_statement
    (43) if_statement -> IF . expression THEN compound_statement ELSE compound_statement
    (48) expression -> . expression and_or expression_m
    (49) expression -> . expression_m
    (50) expression_m -> . element
    (51) expression_m -> . expression_m sign element
    (66) element -> . BOOLEAN
    (67) element -> . NOT element
    (68) element -> . identifier
    (69) element -> . real
    (70) element -> . integer
    (71) element -> . char
    (72) element -> . string
    (73) element -> . LPAREN expression RPAREN
    (74) element -> . function_call
    (75) element -> . empty
    (77) identifier -> . IDENTIFIER
    (78) real -> . REAL
    (79) integer -> . INTEGER
    (81) char -> . CHAR
    (80) string -> . STRING
    (76) function_call -> . identifier LPAREN variables_list RPAREN
    (1) empty -> .

    BOOLEAN         shift and go to state 65
    NOT             shift and go to state 66
    LPAREN          shift and go to state 72
    IDENTIFIER      shift and go to state 4
    REAL            shift and go to state 75
    INTEGER         shift and go to state 76
    CHAR            shift and go to state 77
    STRING          shift and go to state 78
    PLUS            reduce using rule 1 (empty -> .)
    MINUS           reduce using rule 1 (empty -> .)
    INT_DIV         reduce using rule 1 (empty -> .)
    FLOAT_DIV       reduce using rule 1 (empty -> .)
    MULTIPLY        reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    EQ              reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    LTE             reduce using rule 1 (empty -> .)
    GTE             reduce using rule 1 (empty -> .)
    THEN            reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)

    expression                     shift and go to state 62
    expression_m                   shift and go to state 63
    element                        shift and go to state 64
    identifier                     shift and go to state 67
    real                           shift and go to state 68
    integer                        shift and go to state 69
    char                           shift and go to state 70
    string                         shift and go to state 71
    function_call                  shift and go to state 73
    empty                          shift and go to state 74

state 42

    (44) while_statement -> WHILE . expression DO statement
    (48) expression -> . expression and_or expression_m
    (49) expression -> . expression_m
    (50) expression_m -> . element
    (51) expression_m -> . expression_m sign element
    (66) element -> . BOOLEAN
    (67) element -> . NOT element
    (68) element -> . identifier
    (69) element -> . real
    (70) element -> . integer
    (71) element -> . char
    (72) element -> . string
    (73) element -> . LPAREN expression RPAREN
    (74) element -> . function_call
    (75) element -> . empty
    (77) identifier -> . IDENTIFIER
    (78) real -> . REAL
    (79) integer -> . INTEGER
    (81) char -> . CHAR
    (80) string -> . STRING
    (76) function_call -> . identifier LPAREN variables_list RPAREN
    (1) empty -> .

    BOOLEAN         shift and go to state 65
    NOT             shift and go to state 66
    LPAREN          shift and go to state 72
    IDENTIFIER      shift and go to state 4
    REAL            shift and go to state 75
    INTEGER         shift and go to state 76
    CHAR            shift and go to state 77
    STRING          shift and go to state 78
    PLUS            reduce using rule 1 (empty -> .)
    MINUS           reduce using rule 1 (empty -> .)
    INT_DIV         reduce using rule 1 (empty -> .)
    FLOAT_DIV       reduce using rule 1 (empty -> .)
    MULTIPLY        reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    EQ              reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    LTE             reduce using rule 1 (empty -> .)
    GTE             reduce using rule 1 (empty -> .)
    DO              reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)

    expression                     shift and go to state 79
    expression_m                   shift and go to state 63
    element                        shift and go to state 64
    identifier                     shift and go to state 67
    real                           shift and go to state 68
    integer                        shift and go to state 69
    char                           shift and go to state 70
    string                         shift and go to state 71
    function_call                  shift and go to state 73
    empty                          shift and go to state 74

state 43

    (45) repeat_statement -> REPEAT . statement_sequence UNTIL expression
    (28) statement_sequence -> . statement SEMICOLON statement_sequence
    (29) statement_sequence -> . statement SEMICOLON
    (30) statement -> . compound_statement
    (31) statement -> . assignment_statement
    (32) statement -> . if_statement
    (33) statement -> . while_statement
    (34) statement -> . repeat_statement
    (35) statement -> . for_statement
    (36) statement -> . procedure_or_function_call
    (27) compound_statement -> . BEGIN statement_sequence END
    (41) assignment_statement -> . identifier ASSIGNMENT expression
    (42) if_statement -> . IF expression THEN compound_statement
    (43) if_statement -> . IF expression THEN compound_statement ELSE compound_statement
    (44) while_statement -> . WHILE expression DO statement
    (45) repeat_statement -> . REPEAT statement_sequence UNTIL expression
    (46) for_statement -> . FOR assignment_statement TO expression DO statement
    (47) for_statement -> . FOR assignment_statement DOWNTO expression DO statement
    (37) procedure_or_function_call -> . identifier
    (38) procedure_or_function_call -> . identifier LPAREN variables_list RPAREN
    (77) identifier -> . IDENTIFIER

    BEGIN           shift and go to state 22
    IF              shift and go to state 41
    WHILE           shift and go to state 42
    REPEAT          shift and go to state 43
    FOR             shift and go to state 44
    IDENTIFIER      shift and go to state 4

    statement_sequence             shift and go to state 80
    statement                      shift and go to state 32
    compound_statement             shift and go to state 33
    assignment_statement           shift and go to state 34
    if_statement                   shift and go to state 35
    while_statement                shift and go to state 36
    repeat_statement               shift and go to state 37
    for_statement                  shift and go to state 38
    procedure_or_function_call     shift and go to state 39
    identifier                     shift and go to state 40

state 44

    (46) for_statement -> FOR . assignment_statement TO expression DO statement
    (47) for_statement -> FOR . assignment_statement DOWNTO expression DO statement
    (41) assignment_statement -> . identifier ASSIGNMENT expression
    (77) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    assignment_statement           shift and go to state 81
    identifier                     shift and go to state 82

state 45

    (14) procedure_or_function -> proc_or_func_declaration SEMICOLON procedure_or_function .

    BEGIN           reduce using rule 14 (procedure_or_function -> proc_or_func_declaration SEMICOLON procedure_or_function .)


state 46

    (24) procedure_declaration -> procedure_heading SEMICOLON block .

    SEMICOLON       reduce using rule 24 (procedure_declaration -> procedure_heading SEMICOLON block .)


state 47

    (3) block -> variable_declaration_part . procedure_or_function compound_statement
    (14) procedure_or_function -> . proc_or_func_declaration SEMICOLON procedure_or_function
    (15) procedure_or_function -> . empty
    (16) proc_or_func_declaration -> . procedure_declaration
    (17) proc_or_func_declaration -> . function_declaration
    (1) empty -> .
    (24) procedure_declaration -> . procedure_heading SEMICOLON block
    (18) function_declaration -> . function_heading SEMICOLON block
    (25) procedure_heading -> . PROCEDURE identifier
    (26) procedure_heading -> . PROCEDURE identifier LPAREN parameters_list RPAREN
    (19) function_heading -> . FUNCTION identifier COLON type
    (20) function_heading -> . FUNCTION identifier LPAREN parameters_list RPAREN COLON type

    BEGIN           reduce using rule 1 (empty -> .)
    PROCEDURE       shift and go to state 16
    FUNCTION        shift and go to state 17

    procedure_or_function          shift and go to state 83
    proc_or_func_declaration       shift and go to state 10
    empty                          shift and go to state 11
    procedure_declaration          shift and go to state 12
    function_declaration           shift and go to state 13
    procedure_heading              shift and go to state 14
    function_heading               shift and go to state 15

state 48

    (18) function_declaration -> function_heading SEMICOLON block .

    SEMICOLON       reduce using rule 18 (function_declaration -> function_heading SEMICOLON block .)


state 49

    (26) procedure_heading -> PROCEDURE identifier LPAREN . parameters_list RPAREN
    (21) parameters_list -> . parameter COMMA parameters_list
    (22) parameters_list -> . parameter
    (23) parameter -> . identifier COLON type
    (77) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    identifier                     shift and go to state 84
    parameters_list                shift and go to state 85
    parameter                      shift and go to state 86

state 50

    (19) function_heading -> FUNCTION identifier COLON . type
    (9) type -> . SINTEGER
    (10) type -> . SCHAR
    (11) type -> . SREAL
    (12) type -> . SSTRING
    (13) type -> . SBOOLEAN

    SINTEGER        shift and go to state 53
    SCHAR           shift and go to state 54
    SREAL           shift and go to state 55
    SSTRING         shift and go to state 56
    SBOOLEAN        shift and go to state 57

    type                           shift and go to state 87

state 51

    (20) function_heading -> FUNCTION identifier LPAREN . parameters_list RPAREN COLON type
    (21) parameters_list -> . parameter COMMA parameters_list
    (22) parameters_list -> . parameter
    (23) parameter -> . identifier COLON type
    (77) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    identifier                     shift and go to state 84
    parameters_list                shift and go to state 88
    parameter                      shift and go to state 86

state 52

    (8) variable_declaration -> identifier COLON type . SEMICOLON

    SEMICOLON       shift and go to state 89


state 53

    (9) type -> SINTEGER .

    SEMICOLON       reduce using rule 9 (type -> SINTEGER .)
    COMMA           reduce using rule 9 (type -> SINTEGER .)
    RPAREN          reduce using rule 9 (type -> SINTEGER .)


state 54

    (10) type -> SCHAR .

    SEMICOLON       reduce using rule 10 (type -> SCHAR .)
    COMMA           reduce using rule 10 (type -> SCHAR .)
    RPAREN          reduce using rule 10 (type -> SCHAR .)


state 55

    (11) type -> SREAL .

    SEMICOLON       reduce using rule 11 (type -> SREAL .)
    COMMA           reduce using rule 11 (type -> SREAL .)
    RPAREN          reduce using rule 11 (type -> SREAL .)


state 56

    (12) type -> SSTRING .

    SEMICOLON       reduce using rule 12 (type -> SSTRING .)
    COMMA           reduce using rule 12 (type -> SSTRING .)
    RPAREN          reduce using rule 12 (type -> SSTRING .)


state 57

    (13) type -> SBOOLEAN .

    SEMICOLON       reduce using rule 13 (type -> SBOOLEAN .)
    COMMA           reduce using rule 13 (type -> SBOOLEAN .)
    RPAREN          reduce using rule 13 (type -> SBOOLEAN .)


state 58

    (27) compound_statement -> BEGIN statement_sequence END .

    DOT             reduce using rule 27 (compound_statement -> BEGIN statement_sequence END .)
    SEMICOLON       reduce using rule 27 (compound_statement -> BEGIN statement_sequence END .)
    ELSE            reduce using rule 27 (compound_statement -> BEGIN statement_sequence END .)


state 59

    (28) statement_sequence -> statement SEMICOLON . statement_sequence
    (29) statement_sequence -> statement SEMICOLON .
    (28) statement_sequence -> . statement SEMICOLON statement_sequence
    (29) statement_sequence -> . statement SEMICOLON
    (30) statement -> . compound_statement
    (31) statement -> . assignment_statement
    (32) statement -> . if_statement
    (33) statement -> . while_statement
    (34) statement -> . repeat_statement
    (35) statement -> . for_statement
    (36) statement -> . procedure_or_function_call
    (27) compound_statement -> . BEGIN statement_sequence END
    (41) assignment_statement -> . identifier ASSIGNMENT expression
    (42) if_statement -> . IF expression THEN compound_statement
    (43) if_statement -> . IF expression THEN compound_statement ELSE compound_statement
    (44) while_statement -> . WHILE expression DO statement
    (45) repeat_statement -> . REPEAT statement_sequence UNTIL expression
    (46) for_statement -> . FOR assignment_statement TO expression DO statement
    (47) for_statement -> . FOR assignment_statement DOWNTO expression DO statement
    (37) procedure_or_function_call -> . identifier
    (38) procedure_or_function_call -> . identifier LPAREN variables_list RPAREN
    (77) identifier -> . IDENTIFIER

    END             reduce using rule 29 (statement_sequence -> statement SEMICOLON .)
    UNTIL           reduce using rule 29 (statement_sequence -> statement SEMICOLON .)
    BEGIN           shift and go to state 22
    IF              shift and go to state 41
    WHILE           shift and go to state 42
    REPEAT          shift and go to state 43
    FOR             shift and go to state 44
    IDENTIFIER      shift and go to state 4

    statement                      shift and go to state 32
    statement_sequence             shift and go to state 90
    compound_statement             shift and go to state 33
    assignment_statement           shift and go to state 34
    if_statement                   shift and go to state 35
    while_statement                shift and go to state 36
    repeat_statement               shift and go to state 37
    for_statement                  shift and go to state 38
    procedure_or_function_call     shift and go to state 39
    identifier                     shift and go to state 40

state 60

    (41) assignment_statement -> identifier ASSIGNMENT . expression
    (48) expression -> . expression and_or expression_m
    (49) expression -> . expression_m
    (50) expression_m -> . element
    (51) expression_m -> . expression_m sign element
    (66) element -> . BOOLEAN
    (67) element -> . NOT element
    (68) element -> . identifier
    (69) element -> . real
    (70) element -> . integer
    (71) element -> . char
    (72) element -> . string
    (73) element -> . LPAREN expression RPAREN
    (74) element -> . function_call
    (75) element -> . empty
    (77) identifier -> . IDENTIFIER
    (78) real -> . REAL
    (79) integer -> . INTEGER
    (81) char -> . CHAR
    (80) string -> . STRING
    (76) function_call -> . identifier LPAREN variables_list RPAREN
    (1) empty -> .

    BOOLEAN         shift and go to state 65
    NOT             shift and go to state 66
    LPAREN          shift and go to state 72
    IDENTIFIER      shift and go to state 4
    REAL            shift and go to state 75
    INTEGER         shift and go to state 76
    CHAR            shift and go to state 77
    STRING          shift and go to state 78
    PLUS            reduce using rule 1 (empty -> .)
    MINUS           reduce using rule 1 (empty -> .)
    INT_DIV         reduce using rule 1 (empty -> .)
    FLOAT_DIV       reduce using rule 1 (empty -> .)
    MULTIPLY        reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    EQ              reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    LTE             reduce using rule 1 (empty -> .)
    GTE             reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    TO              reduce using rule 1 (empty -> .)
    DOWNTO          reduce using rule 1 (empty -> .)

    identifier                     shift and go to state 67
    expression                     shift and go to state 91
    expression_m                   shift and go to state 63
    element                        shift and go to state 64
    real                           shift and go to state 68
    integer                        shift and go to state 69
    char                           shift and go to state 70
    string                         shift and go to state 71
    function_call                  shift and go to state 73
    empty                          shift and go to state 74

state 61

    (38) procedure_or_function_call -> identifier LPAREN . variables_list RPAREN
    (39) variables_list -> . variables_list COMMA expression
    (40) variables_list -> . expression
    (48) expression -> . expression and_or expression_m
    (49) expression -> . expression_m
    (50) expression_m -> . element
    (51) expression_m -> . expression_m sign element
    (66) element -> . BOOLEAN
    (67) element -> . NOT element
    (68) element -> . identifier
    (69) element -> . real
    (70) element -> . integer
    (71) element -> . char
    (72) element -> . string
    (73) element -> . LPAREN expression RPAREN
    (74) element -> . function_call
    (75) element -> . empty
    (77) identifier -> . IDENTIFIER
    (78) real -> . REAL
    (79) integer -> . INTEGER
    (81) char -> . CHAR
    (80) string -> . STRING
    (76) function_call -> . identifier LPAREN variables_list RPAREN
    (1) empty -> .

    BOOLEAN         shift and go to state 65
    NOT             shift and go to state 66
    LPAREN          shift and go to state 72
    IDENTIFIER      shift and go to state 4
    REAL            shift and go to state 75
    INTEGER         shift and go to state 76
    CHAR            shift and go to state 77
    STRING          shift and go to state 78
    PLUS            reduce using rule 1 (empty -> .)
    MINUS           reduce using rule 1 (empty -> .)
    INT_DIV         reduce using rule 1 (empty -> .)
    FLOAT_DIV       reduce using rule 1 (empty -> .)
    MULTIPLY        reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    EQ              reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    LTE             reduce using rule 1 (empty -> .)
    GTE             reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    RPAREN          reduce using rule 1 (empty -> .)
    COMMA           reduce using rule 1 (empty -> .)

    identifier                     shift and go to state 67
    variables_list                 shift and go to state 92
    expression                     shift and go to state 93
    expression_m                   shift and go to state 63
    element                        shift and go to state 64
    real                           shift and go to state 68
    integer                        shift and go to state 69
    char                           shift and go to state 70
    string                         shift and go to state 71
    function_call                  shift and go to state 73
    empty                          shift and go to state 74

state 62

    (42) if_statement -> IF expression . THEN compound_statement
    (43) if_statement -> IF expression . THEN compound_statement ELSE compound_statement
    (48) expression -> expression . and_or expression_m
    (52) and_or -> . AND
    (53) and_or -> . OR

    THEN            shift and go to state 94
    AND             shift and go to state 96
    OR              shift and go to state 97

    and_or                         shift and go to state 95

state 63

    (49) expression -> expression_m .
    (51) expression_m -> expression_m . sign element
    (54) sign -> . PLUS
    (55) sign -> . MINUS
    (56) sign -> . INT_DIV
    (57) sign -> . FLOAT_DIV
    (58) sign -> . MULTIPLY
    (59) sign -> . MOD
    (60) sign -> . EQ
    (61) sign -> . NEQ
    (62) sign -> . LT
    (63) sign -> . GT
    (64) sign -> . LTE
    (65) sign -> . GTE

    THEN            reduce using rule 49 (expression -> expression_m .)
    AND             reduce using rule 49 (expression -> expression_m .)
    OR              reduce using rule 49 (expression -> expression_m .)
    DO              reduce using rule 49 (expression -> expression_m .)
    SEMICOLON       reduce using rule 49 (expression -> expression_m .)
    TO              reduce using rule 49 (expression -> expression_m .)
    DOWNTO          reduce using rule 49 (expression -> expression_m .)
    RPAREN          reduce using rule 49 (expression -> expression_m .)
    COMMA           reduce using rule 49 (expression -> expression_m .)
    PLUS            shift and go to state 99
    MINUS           shift and go to state 100
    INT_DIV         shift and go to state 101
    FLOAT_DIV       shift and go to state 102
    MULTIPLY        shift and go to state 103
    MOD             shift and go to state 104
    EQ              shift and go to state 105
    NEQ             shift and go to state 106
    LT              shift and go to state 107
    GT              shift and go to state 108
    LTE             shift and go to state 109
    GTE             shift and go to state 110

    sign                           shift and go to state 98

state 64

    (50) expression_m -> element .

    PLUS            reduce using rule 50 (expression_m -> element .)
    MINUS           reduce using rule 50 (expression_m -> element .)
    INT_DIV         reduce using rule 50 (expression_m -> element .)
    FLOAT_DIV       reduce using rule 50 (expression_m -> element .)
    MULTIPLY        reduce using rule 50 (expression_m -> element .)
    MOD             reduce using rule 50 (expression_m -> element .)
    EQ              reduce using rule 50 (expression_m -> element .)
    NEQ             reduce using rule 50 (expression_m -> element .)
    LT              reduce using rule 50 (expression_m -> element .)
    GT              reduce using rule 50 (expression_m -> element .)
    LTE             reduce using rule 50 (expression_m -> element .)
    GTE             reduce using rule 50 (expression_m -> element .)
    THEN            reduce using rule 50 (expression_m -> element .)
    AND             reduce using rule 50 (expression_m -> element .)
    OR              reduce using rule 50 (expression_m -> element .)
    DO              reduce using rule 50 (expression_m -> element .)
    SEMICOLON       reduce using rule 50 (expression_m -> element .)
    TO              reduce using rule 50 (expression_m -> element .)
    DOWNTO          reduce using rule 50 (expression_m -> element .)
    RPAREN          reduce using rule 50 (expression_m -> element .)
    COMMA           reduce using rule 50 (expression_m -> element .)


state 65

    (66) element -> BOOLEAN .

    PLUS            reduce using rule 66 (element -> BOOLEAN .)
    MINUS           reduce using rule 66 (element -> BOOLEAN .)
    INT_DIV         reduce using rule 66 (element -> BOOLEAN .)
    FLOAT_DIV       reduce using rule 66 (element -> BOOLEAN .)
    MULTIPLY        reduce using rule 66 (element -> BOOLEAN .)
    MOD             reduce using rule 66 (element -> BOOLEAN .)
    EQ              reduce using rule 66 (element -> BOOLEAN .)
    NEQ             reduce using rule 66 (element -> BOOLEAN .)
    LT              reduce using rule 66 (element -> BOOLEAN .)
    GT              reduce using rule 66 (element -> BOOLEAN .)
    LTE             reduce using rule 66 (element -> BOOLEAN .)
    GTE             reduce using rule 66 (element -> BOOLEAN .)
    THEN            reduce using rule 66 (element -> BOOLEAN .)
    AND             reduce using rule 66 (element -> BOOLEAN .)
    OR              reduce using rule 66 (element -> BOOLEAN .)
    DO              reduce using rule 66 (element -> BOOLEAN .)
    SEMICOLON       reduce using rule 66 (element -> BOOLEAN .)
    TO              reduce using rule 66 (element -> BOOLEAN .)
    DOWNTO          reduce using rule 66 (element -> BOOLEAN .)
    RPAREN          reduce using rule 66 (element -> BOOLEAN .)
    COMMA           reduce using rule 66 (element -> BOOLEAN .)


state 66

    (67) element -> NOT . element
    (66) element -> . BOOLEAN
    (67) element -> . NOT element
    (68) element -> . identifier
    (69) element -> . real
    (70) element -> . integer
    (71) element -> . char
    (72) element -> . string
    (73) element -> . LPAREN expression RPAREN
    (74) element -> . function_call
    (75) element -> . empty
    (77) identifier -> . IDENTIFIER
    (78) real -> . REAL
    (79) integer -> . INTEGER
    (81) char -> . CHAR
    (80) string -> . STRING
    (76) function_call -> . identifier LPAREN variables_list RPAREN
    (1) empty -> .

    BOOLEAN         shift and go to state 65
    NOT             shift and go to state 66
    LPAREN          shift and go to state 72
    IDENTIFIER      shift and go to state 4
    REAL            shift and go to state 75
    INTEGER         shift and go to state 76
    CHAR            shift and go to state 77
    STRING          shift and go to state 78
    PLUS            reduce using rule 1 (empty -> .)
    MINUS           reduce using rule 1 (empty -> .)
    INT_DIV         reduce using rule 1 (empty -> .)
    FLOAT_DIV       reduce using rule 1 (empty -> .)
    MULTIPLY        reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    EQ              reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    LTE             reduce using rule 1 (empty -> .)
    GTE             reduce using rule 1 (empty -> .)
    THEN            reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    DO              reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    TO              reduce using rule 1 (empty -> .)
    DOWNTO          reduce using rule 1 (empty -> .)
    RPAREN          reduce using rule 1 (empty -> .)
    COMMA           reduce using rule 1 (empty -> .)

    element                        shift and go to state 111
    identifier                     shift and go to state 67
    real                           shift and go to state 68
    integer                        shift and go to state 69
    char                           shift and go to state 70
    string                         shift and go to state 71
    function_call                  shift and go to state 73
    empty                          shift and go to state 74

state 67

    (68) element -> identifier .
    (76) function_call -> identifier . LPAREN variables_list RPAREN

    PLUS            reduce using rule 68 (element -> identifier .)
    MINUS           reduce using rule 68 (element -> identifier .)
    INT_DIV         reduce using rule 68 (element -> identifier .)
    FLOAT_DIV       reduce using rule 68 (element -> identifier .)
    MULTIPLY        reduce using rule 68 (element -> identifier .)
    MOD             reduce using rule 68 (element -> identifier .)
    EQ              reduce using rule 68 (element -> identifier .)
    NEQ             reduce using rule 68 (element -> identifier .)
    LT              reduce using rule 68 (element -> identifier .)
    GT              reduce using rule 68 (element -> identifier .)
    LTE             reduce using rule 68 (element -> identifier .)
    GTE             reduce using rule 68 (element -> identifier .)
    THEN            reduce using rule 68 (element -> identifier .)
    AND             reduce using rule 68 (element -> identifier .)
    OR              reduce using rule 68 (element -> identifier .)
    DO              reduce using rule 68 (element -> identifier .)
    SEMICOLON       reduce using rule 68 (element -> identifier .)
    TO              reduce using rule 68 (element -> identifier .)
    DOWNTO          reduce using rule 68 (element -> identifier .)
    RPAREN          reduce using rule 68 (element -> identifier .)
    COMMA           reduce using rule 68 (element -> identifier .)
    LPAREN          shift and go to state 112


state 68

    (69) element -> real .

    PLUS            reduce using rule 69 (element -> real .)
    MINUS           reduce using rule 69 (element -> real .)
    INT_DIV         reduce using rule 69 (element -> real .)
    FLOAT_DIV       reduce using rule 69 (element -> real .)
    MULTIPLY        reduce using rule 69 (element -> real .)
    MOD             reduce using rule 69 (element -> real .)
    EQ              reduce using rule 69 (element -> real .)
    NEQ             reduce using rule 69 (element -> real .)
    LT              reduce using rule 69 (element -> real .)
    GT              reduce using rule 69 (element -> real .)
    LTE             reduce using rule 69 (element -> real .)
    GTE             reduce using rule 69 (element -> real .)
    THEN            reduce using rule 69 (element -> real .)
    AND             reduce using rule 69 (element -> real .)
    OR              reduce using rule 69 (element -> real .)
    DO              reduce using rule 69 (element -> real .)
    SEMICOLON       reduce using rule 69 (element -> real .)
    TO              reduce using rule 69 (element -> real .)
    DOWNTO          reduce using rule 69 (element -> real .)
    RPAREN          reduce using rule 69 (element -> real .)
    COMMA           reduce using rule 69 (element -> real .)


state 69

    (70) element -> integer .

    PLUS            reduce using rule 70 (element -> integer .)
    MINUS           reduce using rule 70 (element -> integer .)
    INT_DIV         reduce using rule 70 (element -> integer .)
    FLOAT_DIV       reduce using rule 70 (element -> integer .)
    MULTIPLY        reduce using rule 70 (element -> integer .)
    MOD             reduce using rule 70 (element -> integer .)
    EQ              reduce using rule 70 (element -> integer .)
    NEQ             reduce using rule 70 (element -> integer .)
    LT              reduce using rule 70 (element -> integer .)
    GT              reduce using rule 70 (element -> integer .)
    LTE             reduce using rule 70 (element -> integer .)
    GTE             reduce using rule 70 (element -> integer .)
    THEN            reduce using rule 70 (element -> integer .)
    AND             reduce using rule 70 (element -> integer .)
    OR              reduce using rule 70 (element -> integer .)
    DO              reduce using rule 70 (element -> integer .)
    SEMICOLON       reduce using rule 70 (element -> integer .)
    TO              reduce using rule 70 (element -> integer .)
    DOWNTO          reduce using rule 70 (element -> integer .)
    RPAREN          reduce using rule 70 (element -> integer .)
    COMMA           reduce using rule 70 (element -> integer .)


state 70

    (71) element -> char .

    PLUS            reduce using rule 71 (element -> char .)
    MINUS           reduce using rule 71 (element -> char .)
    INT_DIV         reduce using rule 71 (element -> char .)
    FLOAT_DIV       reduce using rule 71 (element -> char .)
    MULTIPLY        reduce using rule 71 (element -> char .)
    MOD             reduce using rule 71 (element -> char .)
    EQ              reduce using rule 71 (element -> char .)
    NEQ             reduce using rule 71 (element -> char .)
    LT              reduce using rule 71 (element -> char .)
    GT              reduce using rule 71 (element -> char .)
    LTE             reduce using rule 71 (element -> char .)
    GTE             reduce using rule 71 (element -> char .)
    THEN            reduce using rule 71 (element -> char .)
    AND             reduce using rule 71 (element -> char .)
    OR              reduce using rule 71 (element -> char .)
    DO              reduce using rule 71 (element -> char .)
    SEMICOLON       reduce using rule 71 (element -> char .)
    TO              reduce using rule 71 (element -> char .)
    DOWNTO          reduce using rule 71 (element -> char .)
    RPAREN          reduce using rule 71 (element -> char .)
    COMMA           reduce using rule 71 (element -> char .)


state 71

    (72) element -> string .

    PLUS            reduce using rule 72 (element -> string .)
    MINUS           reduce using rule 72 (element -> string .)
    INT_DIV         reduce using rule 72 (element -> string .)
    FLOAT_DIV       reduce using rule 72 (element -> string .)
    MULTIPLY        reduce using rule 72 (element -> string .)
    MOD             reduce using rule 72 (element -> string .)
    EQ              reduce using rule 72 (element -> string .)
    NEQ             reduce using rule 72 (element -> string .)
    LT              reduce using rule 72 (element -> string .)
    GT              reduce using rule 72 (element -> string .)
    LTE             reduce using rule 72 (element -> string .)
    GTE             reduce using rule 72 (element -> string .)
    THEN            reduce using rule 72 (element -> string .)
    AND             reduce using rule 72 (element -> string .)
    OR              reduce using rule 72 (element -> string .)
    DO              reduce using rule 72 (element -> string .)
    SEMICOLON       reduce using rule 72 (element -> string .)
    TO              reduce using rule 72 (element -> string .)
    DOWNTO          reduce using rule 72 (element -> string .)
    RPAREN          reduce using rule 72 (element -> string .)
    COMMA           reduce using rule 72 (element -> string .)


state 72

    (73) element -> LPAREN . expression RPAREN
    (48) expression -> . expression and_or expression_m
    (49) expression -> . expression_m
    (50) expression_m -> . element
    (51) expression_m -> . expression_m sign element
    (66) element -> . BOOLEAN
    (67) element -> . NOT element
    (68) element -> . identifier
    (69) element -> . real
    (70) element -> . integer
    (71) element -> . char
    (72) element -> . string
    (73) element -> . LPAREN expression RPAREN
    (74) element -> . function_call
    (75) element -> . empty
    (77) identifier -> . IDENTIFIER
    (78) real -> . REAL
    (79) integer -> . INTEGER
    (81) char -> . CHAR
    (80) string -> . STRING
    (76) function_call -> . identifier LPAREN variables_list RPAREN
    (1) empty -> .

    BOOLEAN         shift and go to state 65
    NOT             shift and go to state 66
    LPAREN          shift and go to state 72
    IDENTIFIER      shift and go to state 4
    REAL            shift and go to state 75
    INTEGER         shift and go to state 76
    CHAR            shift and go to state 77
    STRING          shift and go to state 78
    PLUS            reduce using rule 1 (empty -> .)
    MINUS           reduce using rule 1 (empty -> .)
    INT_DIV         reduce using rule 1 (empty -> .)
    FLOAT_DIV       reduce using rule 1 (empty -> .)
    MULTIPLY        reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    EQ              reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    LTE             reduce using rule 1 (empty -> .)
    GTE             reduce using rule 1 (empty -> .)
    RPAREN          reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)

    expression                     shift and go to state 113
    expression_m                   shift and go to state 63
    element                        shift and go to state 64
    identifier                     shift and go to state 67
    real                           shift and go to state 68
    integer                        shift and go to state 69
    char                           shift and go to state 70
    string                         shift and go to state 71
    function_call                  shift and go to state 73
    empty                          shift and go to state 74

state 73

    (74) element -> function_call .

    PLUS            reduce using rule 74 (element -> function_call .)
    MINUS           reduce using rule 74 (element -> function_call .)
    INT_DIV         reduce using rule 74 (element -> function_call .)
    FLOAT_DIV       reduce using rule 74 (element -> function_call .)
    MULTIPLY        reduce using rule 74 (element -> function_call .)
    MOD             reduce using rule 74 (element -> function_call .)
    EQ              reduce using rule 74 (element -> function_call .)
    NEQ             reduce using rule 74 (element -> function_call .)
    LT              reduce using rule 74 (element -> function_call .)
    GT              reduce using rule 74 (element -> function_call .)
    LTE             reduce using rule 74 (element -> function_call .)
    GTE             reduce using rule 74 (element -> function_call .)
    THEN            reduce using rule 74 (element -> function_call .)
    AND             reduce using rule 74 (element -> function_call .)
    OR              reduce using rule 74 (element -> function_call .)
    DO              reduce using rule 74 (element -> function_call .)
    SEMICOLON       reduce using rule 74 (element -> function_call .)
    TO              reduce using rule 74 (element -> function_call .)
    DOWNTO          reduce using rule 74 (element -> function_call .)
    RPAREN          reduce using rule 74 (element -> function_call .)
    COMMA           reduce using rule 74 (element -> function_call .)


state 74

    (75) element -> empty .

    PLUS            reduce using rule 75 (element -> empty .)
    MINUS           reduce using rule 75 (element -> empty .)
    INT_DIV         reduce using rule 75 (element -> empty .)
    FLOAT_DIV       reduce using rule 75 (element -> empty .)
    MULTIPLY        reduce using rule 75 (element -> empty .)
    MOD             reduce using rule 75 (element -> empty .)
    EQ              reduce using rule 75 (element -> empty .)
    NEQ             reduce using rule 75 (element -> empty .)
    LT              reduce using rule 75 (element -> empty .)
    GT              reduce using rule 75 (element -> empty .)
    LTE             reduce using rule 75 (element -> empty .)
    GTE             reduce using rule 75 (element -> empty .)
    THEN            reduce using rule 75 (element -> empty .)
    AND             reduce using rule 75 (element -> empty .)
    OR              reduce using rule 75 (element -> empty .)
    DO              reduce using rule 75 (element -> empty .)
    SEMICOLON       reduce using rule 75 (element -> empty .)
    TO              reduce using rule 75 (element -> empty .)
    DOWNTO          reduce using rule 75 (element -> empty .)
    RPAREN          reduce using rule 75 (element -> empty .)
    COMMA           reduce using rule 75 (element -> empty .)


state 75

    (78) real -> REAL .

    PLUS            reduce using rule 78 (real -> REAL .)
    MINUS           reduce using rule 78 (real -> REAL .)
    INT_DIV         reduce using rule 78 (real -> REAL .)
    FLOAT_DIV       reduce using rule 78 (real -> REAL .)
    MULTIPLY        reduce using rule 78 (real -> REAL .)
    MOD             reduce using rule 78 (real -> REAL .)
    EQ              reduce using rule 78 (real -> REAL .)
    NEQ             reduce using rule 78 (real -> REAL .)
    LT              reduce using rule 78 (real -> REAL .)
    GT              reduce using rule 78 (real -> REAL .)
    LTE             reduce using rule 78 (real -> REAL .)
    GTE             reduce using rule 78 (real -> REAL .)
    THEN            reduce using rule 78 (real -> REAL .)
    AND             reduce using rule 78 (real -> REAL .)
    OR              reduce using rule 78 (real -> REAL .)
    DO              reduce using rule 78 (real -> REAL .)
    SEMICOLON       reduce using rule 78 (real -> REAL .)
    TO              reduce using rule 78 (real -> REAL .)
    DOWNTO          reduce using rule 78 (real -> REAL .)
    RPAREN          reduce using rule 78 (real -> REAL .)
    COMMA           reduce using rule 78 (real -> REAL .)


state 76

    (79) integer -> INTEGER .

    PLUS            reduce using rule 79 (integer -> INTEGER .)
    MINUS           reduce using rule 79 (integer -> INTEGER .)
    INT_DIV         reduce using rule 79 (integer -> INTEGER .)
    FLOAT_DIV       reduce using rule 79 (integer -> INTEGER .)
    MULTIPLY        reduce using rule 79 (integer -> INTEGER .)
    MOD             reduce using rule 79 (integer -> INTEGER .)
    EQ              reduce using rule 79 (integer -> INTEGER .)
    NEQ             reduce using rule 79 (integer -> INTEGER .)
    LT              reduce using rule 79 (integer -> INTEGER .)
    GT              reduce using rule 79 (integer -> INTEGER .)
    LTE             reduce using rule 79 (integer -> INTEGER .)
    GTE             reduce using rule 79 (integer -> INTEGER .)
    THEN            reduce using rule 79 (integer -> INTEGER .)
    AND             reduce using rule 79 (integer -> INTEGER .)
    OR              reduce using rule 79 (integer -> INTEGER .)
    DO              reduce using rule 79 (integer -> INTEGER .)
    SEMICOLON       reduce using rule 79 (integer -> INTEGER .)
    TO              reduce using rule 79 (integer -> INTEGER .)
    DOWNTO          reduce using rule 79 (integer -> INTEGER .)
    RPAREN          reduce using rule 79 (integer -> INTEGER .)
    COMMA           reduce using rule 79 (integer -> INTEGER .)


state 77

    (81) char -> CHAR .

    PLUS            reduce using rule 81 (char -> CHAR .)
    MINUS           reduce using rule 81 (char -> CHAR .)
    INT_DIV         reduce using rule 81 (char -> CHAR .)
    FLOAT_DIV       reduce using rule 81 (char -> CHAR .)
    MULTIPLY        reduce using rule 81 (char -> CHAR .)
    MOD             reduce using rule 81 (char -> CHAR .)
    EQ              reduce using rule 81 (char -> CHAR .)
    NEQ             reduce using rule 81 (char -> CHAR .)
    LT              reduce using rule 81 (char -> CHAR .)
    GT              reduce using rule 81 (char -> CHAR .)
    LTE             reduce using rule 81 (char -> CHAR .)
    GTE             reduce using rule 81 (char -> CHAR .)
    THEN            reduce using rule 81 (char -> CHAR .)
    AND             reduce using rule 81 (char -> CHAR .)
    OR              reduce using rule 81 (char -> CHAR .)
    DO              reduce using rule 81 (char -> CHAR .)
    SEMICOLON       reduce using rule 81 (char -> CHAR .)
    TO              reduce using rule 81 (char -> CHAR .)
    DOWNTO          reduce using rule 81 (char -> CHAR .)
    RPAREN          reduce using rule 81 (char -> CHAR .)
    COMMA           reduce using rule 81 (char -> CHAR .)


state 78

    (80) string -> STRING .

    PLUS            reduce using rule 80 (string -> STRING .)
    MINUS           reduce using rule 80 (string -> STRING .)
    INT_DIV         reduce using rule 80 (string -> STRING .)
    FLOAT_DIV       reduce using rule 80 (string -> STRING .)
    MULTIPLY        reduce using rule 80 (string -> STRING .)
    MOD             reduce using rule 80 (string -> STRING .)
    EQ              reduce using rule 80 (string -> STRING .)
    NEQ             reduce using rule 80 (string -> STRING .)
    LT              reduce using rule 80 (string -> STRING .)
    GT              reduce using rule 80 (string -> STRING .)
    LTE             reduce using rule 80 (string -> STRING .)
    GTE             reduce using rule 80 (string -> STRING .)
    THEN            reduce using rule 80 (string -> STRING .)
    AND             reduce using rule 80 (string -> STRING .)
    OR              reduce using rule 80 (string -> STRING .)
    DO              reduce using rule 80 (string -> STRING .)
    SEMICOLON       reduce using rule 80 (string -> STRING .)
    TO              reduce using rule 80 (string -> STRING .)
    DOWNTO          reduce using rule 80 (string -> STRING .)
    RPAREN          reduce using rule 80 (string -> STRING .)
    COMMA           reduce using rule 80 (string -> STRING .)


state 79

    (44) while_statement -> WHILE expression . DO statement
    (48) expression -> expression . and_or expression_m
    (52) and_or -> . AND
    (53) and_or -> . OR

    DO              shift and go to state 114
    AND             shift and go to state 96
    OR              shift and go to state 97

    and_or                         shift and go to state 95

state 80

    (45) repeat_statement -> REPEAT statement_sequence . UNTIL expression

    UNTIL           shift and go to state 115


state 81

    (46) for_statement -> FOR assignment_statement . TO expression DO statement
    (47) for_statement -> FOR assignment_statement . DOWNTO expression DO statement

    TO              shift and go to state 116
    DOWNTO          shift and go to state 117


state 82

    (41) assignment_statement -> identifier . ASSIGNMENT expression

    ASSIGNMENT      shift and go to state 60


state 83

    (3) block -> variable_declaration_part procedure_or_function . compound_statement
    (27) compound_statement -> . BEGIN statement_sequence END

    BEGIN           shift and go to state 22

    compound_statement             shift and go to state 118

state 84

    (23) parameter -> identifier . COLON type

    COLON           shift and go to state 119


state 85

    (26) procedure_heading -> PROCEDURE identifier LPAREN parameters_list . RPAREN

    RPAREN          shift and go to state 120


state 86

    (21) parameters_list -> parameter . COMMA parameters_list
    (22) parameters_list -> parameter .

    COMMA           shift and go to state 121
    RPAREN          reduce using rule 22 (parameters_list -> parameter .)


state 87

    (19) function_heading -> FUNCTION identifier COLON type .

    SEMICOLON       reduce using rule 19 (function_heading -> FUNCTION identifier COLON type .)


state 88

    (20) function_heading -> FUNCTION identifier LPAREN parameters_list . RPAREN COLON type

    RPAREN          shift and go to state 122


state 89

    (8) variable_declaration -> identifier COLON type SEMICOLON .

    IDENTIFIER      reduce using rule 8 (variable_declaration -> identifier COLON type SEMICOLON .)
    PROCEDURE       reduce using rule 8 (variable_declaration -> identifier COLON type SEMICOLON .)
    FUNCTION        reduce using rule 8 (variable_declaration -> identifier COLON type SEMICOLON .)
    BEGIN           reduce using rule 8 (variable_declaration -> identifier COLON type SEMICOLON .)


state 90

    (28) statement_sequence -> statement SEMICOLON statement_sequence .

    END             reduce using rule 28 (statement_sequence -> statement SEMICOLON statement_sequence .)
    UNTIL           reduce using rule 28 (statement_sequence -> statement SEMICOLON statement_sequence .)


state 91

    (41) assignment_statement -> identifier ASSIGNMENT expression .
    (48) expression -> expression . and_or expression_m
    (52) and_or -> . AND
    (53) and_or -> . OR

    SEMICOLON       reduce using rule 41 (assignment_statement -> identifier ASSIGNMENT expression .)
    TO              reduce using rule 41 (assignment_statement -> identifier ASSIGNMENT expression .)
    DOWNTO          reduce using rule 41 (assignment_statement -> identifier ASSIGNMENT expression .)
    AND             shift and go to state 96
    OR              shift and go to state 97

    and_or                         shift and go to state 95

state 92

    (38) procedure_or_function_call -> identifier LPAREN variables_list . RPAREN
    (39) variables_list -> variables_list . COMMA expression

    RPAREN          shift and go to state 123
    COMMA           shift and go to state 124


state 93

    (40) variables_list -> expression .
    (48) expression -> expression . and_or expression_m
    (52) and_or -> . AND
    (53) and_or -> . OR

    RPAREN          reduce using rule 40 (variables_list -> expression .)
    COMMA           reduce using rule 40 (variables_list -> expression .)
    AND             shift and go to state 96
    OR              shift and go to state 97

    and_or                         shift and go to state 95

state 94

    (42) if_statement -> IF expression THEN . compound_statement
    (43) if_statement -> IF expression THEN . compound_statement ELSE compound_statement
    (27) compound_statement -> . BEGIN statement_sequence END

    BEGIN           shift and go to state 22

    compound_statement             shift and go to state 125

state 95

    (48) expression -> expression and_or . expression_m
    (50) expression_m -> . element
    (51) expression_m -> . expression_m sign element
    (66) element -> . BOOLEAN
    (67) element -> . NOT element
    (68) element -> . identifier
    (69) element -> . real
    (70) element -> . integer
    (71) element -> . char
    (72) element -> . string
    (73) element -> . LPAREN expression RPAREN
    (74) element -> . function_call
    (75) element -> . empty
    (77) identifier -> . IDENTIFIER
    (78) real -> . REAL
    (79) integer -> . INTEGER
    (81) char -> . CHAR
    (80) string -> . STRING
    (76) function_call -> . identifier LPAREN variables_list RPAREN
    (1) empty -> .

    BOOLEAN         shift and go to state 65
    NOT             shift and go to state 66
    LPAREN          shift and go to state 72
    IDENTIFIER      shift and go to state 4
    REAL            shift and go to state 75
    INTEGER         shift and go to state 76
    CHAR            shift and go to state 77
    STRING          shift and go to state 78
    PLUS            reduce using rule 1 (empty -> .)
    MINUS           reduce using rule 1 (empty -> .)
    INT_DIV         reduce using rule 1 (empty -> .)
    FLOAT_DIV       reduce using rule 1 (empty -> .)
    MULTIPLY        reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    EQ              reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    LTE             reduce using rule 1 (empty -> .)
    GTE             reduce using rule 1 (empty -> .)
    THEN            reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    DO              reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    TO              reduce using rule 1 (empty -> .)
    DOWNTO          reduce using rule 1 (empty -> .)
    RPAREN          reduce using rule 1 (empty -> .)
    COMMA           reduce using rule 1 (empty -> .)

    expression_m                   shift and go to state 126
    element                        shift and go to state 64
    identifier                     shift and go to state 67
    real                           shift and go to state 68
    integer                        shift and go to state 69
    char                           shift and go to state 70
    string                         shift and go to state 71
    function_call                  shift and go to state 73
    empty                          shift and go to state 74

state 96

    (52) and_or -> AND .

    BOOLEAN         reduce using rule 52 (and_or -> AND .)
    NOT             reduce using rule 52 (and_or -> AND .)
    LPAREN          reduce using rule 52 (and_or -> AND .)
    IDENTIFIER      reduce using rule 52 (and_or -> AND .)
    REAL            reduce using rule 52 (and_or -> AND .)
    INTEGER         reduce using rule 52 (and_or -> AND .)
    CHAR            reduce using rule 52 (and_or -> AND .)
    STRING          reduce using rule 52 (and_or -> AND .)
    PLUS            reduce using rule 52 (and_or -> AND .)
    MINUS           reduce using rule 52 (and_or -> AND .)
    INT_DIV         reduce using rule 52 (and_or -> AND .)
    FLOAT_DIV       reduce using rule 52 (and_or -> AND .)
    MULTIPLY        reduce using rule 52 (and_or -> AND .)
    MOD             reduce using rule 52 (and_or -> AND .)
    EQ              reduce using rule 52 (and_or -> AND .)
    NEQ             reduce using rule 52 (and_or -> AND .)
    LT              reduce using rule 52 (and_or -> AND .)
    GT              reduce using rule 52 (and_or -> AND .)
    LTE             reduce using rule 52 (and_or -> AND .)
    GTE             reduce using rule 52 (and_or -> AND .)
    THEN            reduce using rule 52 (and_or -> AND .)
    AND             reduce using rule 52 (and_or -> AND .)
    OR              reduce using rule 52 (and_or -> AND .)
    DO              reduce using rule 52 (and_or -> AND .)
    SEMICOLON       reduce using rule 52 (and_or -> AND .)
    TO              reduce using rule 52 (and_or -> AND .)
    DOWNTO          reduce using rule 52 (and_or -> AND .)
    RPAREN          reduce using rule 52 (and_or -> AND .)
    COMMA           reduce using rule 52 (and_or -> AND .)


state 97

    (53) and_or -> OR .

    BOOLEAN         reduce using rule 53 (and_or -> OR .)
    NOT             reduce using rule 53 (and_or -> OR .)
    LPAREN          reduce using rule 53 (and_or -> OR .)
    IDENTIFIER      reduce using rule 53 (and_or -> OR .)
    REAL            reduce using rule 53 (and_or -> OR .)
    INTEGER         reduce using rule 53 (and_or -> OR .)
    CHAR            reduce using rule 53 (and_or -> OR .)
    STRING          reduce using rule 53 (and_or -> OR .)
    PLUS            reduce using rule 53 (and_or -> OR .)
    MINUS           reduce using rule 53 (and_or -> OR .)
    INT_DIV         reduce using rule 53 (and_or -> OR .)
    FLOAT_DIV       reduce using rule 53 (and_or -> OR .)
    MULTIPLY        reduce using rule 53 (and_or -> OR .)
    MOD             reduce using rule 53 (and_or -> OR .)
    EQ              reduce using rule 53 (and_or -> OR .)
    NEQ             reduce using rule 53 (and_or -> OR .)
    LT              reduce using rule 53 (and_or -> OR .)
    GT              reduce using rule 53 (and_or -> OR .)
    LTE             reduce using rule 53 (and_or -> OR .)
    GTE             reduce using rule 53 (and_or -> OR .)
    THEN            reduce using rule 53 (and_or -> OR .)
    AND             reduce using rule 53 (and_or -> OR .)
    OR              reduce using rule 53 (and_or -> OR .)
    DO              reduce using rule 53 (and_or -> OR .)
    SEMICOLON       reduce using rule 53 (and_or -> OR .)
    TO              reduce using rule 53 (and_or -> OR .)
    DOWNTO          reduce using rule 53 (and_or -> OR .)
    RPAREN          reduce using rule 53 (and_or -> OR .)
    COMMA           reduce using rule 53 (and_or -> OR .)


state 98

    (51) expression_m -> expression_m sign . element
    (66) element -> . BOOLEAN
    (67) element -> . NOT element
    (68) element -> . identifier
    (69) element -> . real
    (70) element -> . integer
    (71) element -> . char
    (72) element -> . string
    (73) element -> . LPAREN expression RPAREN
    (74) element -> . function_call
    (75) element -> . empty
    (77) identifier -> . IDENTIFIER
    (78) real -> . REAL
    (79) integer -> . INTEGER
    (81) char -> . CHAR
    (80) string -> . STRING
    (76) function_call -> . identifier LPAREN variables_list RPAREN
    (1) empty -> .

    BOOLEAN         shift and go to state 65
    NOT             shift and go to state 66
    LPAREN          shift and go to state 72
    IDENTIFIER      shift and go to state 4
    REAL            shift and go to state 75
    INTEGER         shift and go to state 76
    CHAR            shift and go to state 77
    STRING          shift and go to state 78
    PLUS            reduce using rule 1 (empty -> .)
    MINUS           reduce using rule 1 (empty -> .)
    INT_DIV         reduce using rule 1 (empty -> .)
    FLOAT_DIV       reduce using rule 1 (empty -> .)
    MULTIPLY        reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    EQ              reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    LTE             reduce using rule 1 (empty -> .)
    GTE             reduce using rule 1 (empty -> .)
    THEN            reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    DO              reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)
    TO              reduce using rule 1 (empty -> .)
    DOWNTO          reduce using rule 1 (empty -> .)
    RPAREN          reduce using rule 1 (empty -> .)
    COMMA           reduce using rule 1 (empty -> .)

    element                        shift and go to state 127
    identifier                     shift and go to state 67
    real                           shift and go to state 68
    integer                        shift and go to state 69
    char                           shift and go to state 70
    string                         shift and go to state 71
    function_call                  shift and go to state 73
    empty                          shift and go to state 74

state 99

    (54) sign -> PLUS .

    BOOLEAN         reduce using rule 54 (sign -> PLUS .)
    NOT             reduce using rule 54 (sign -> PLUS .)
    LPAREN          reduce using rule 54 (sign -> PLUS .)
    IDENTIFIER      reduce using rule 54 (sign -> PLUS .)
    REAL            reduce using rule 54 (sign -> PLUS .)
    INTEGER         reduce using rule 54 (sign -> PLUS .)
    CHAR            reduce using rule 54 (sign -> PLUS .)
    STRING          reduce using rule 54 (sign -> PLUS .)
    PLUS            reduce using rule 54 (sign -> PLUS .)
    MINUS           reduce using rule 54 (sign -> PLUS .)
    INT_DIV         reduce using rule 54 (sign -> PLUS .)
    FLOAT_DIV       reduce using rule 54 (sign -> PLUS .)
    MULTIPLY        reduce using rule 54 (sign -> PLUS .)
    MOD             reduce using rule 54 (sign -> PLUS .)
    EQ              reduce using rule 54 (sign -> PLUS .)
    NEQ             reduce using rule 54 (sign -> PLUS .)
    LT              reduce using rule 54 (sign -> PLUS .)
    GT              reduce using rule 54 (sign -> PLUS .)
    LTE             reduce using rule 54 (sign -> PLUS .)
    GTE             reduce using rule 54 (sign -> PLUS .)
    THEN            reduce using rule 54 (sign -> PLUS .)
    AND             reduce using rule 54 (sign -> PLUS .)
    OR              reduce using rule 54 (sign -> PLUS .)
    DO              reduce using rule 54 (sign -> PLUS .)
    SEMICOLON       reduce using rule 54 (sign -> PLUS .)
    TO              reduce using rule 54 (sign -> PLUS .)
    DOWNTO          reduce using rule 54 (sign -> PLUS .)
    RPAREN          reduce using rule 54 (sign -> PLUS .)
    COMMA           reduce using rule 54 (sign -> PLUS .)


state 100

    (55) sign -> MINUS .

    BOOLEAN         reduce using rule 55 (sign -> MINUS .)
    NOT             reduce using rule 55 (sign -> MINUS .)
    LPAREN          reduce using rule 55 (sign -> MINUS .)
    IDENTIFIER      reduce using rule 55 (sign -> MINUS .)
    REAL            reduce using rule 55 (sign -> MINUS .)
    INTEGER         reduce using rule 55 (sign -> MINUS .)
    CHAR            reduce using rule 55 (sign -> MINUS .)
    STRING          reduce using rule 55 (sign -> MINUS .)
    PLUS            reduce using rule 55 (sign -> MINUS .)
    MINUS           reduce using rule 55 (sign -> MINUS .)
    INT_DIV         reduce using rule 55 (sign -> MINUS .)
    FLOAT_DIV       reduce using rule 55 (sign -> MINUS .)
    MULTIPLY        reduce using rule 55 (sign -> MINUS .)
    MOD             reduce using rule 55 (sign -> MINUS .)
    EQ              reduce using rule 55 (sign -> MINUS .)
    NEQ             reduce using rule 55 (sign -> MINUS .)
    LT              reduce using rule 55 (sign -> MINUS .)
    GT              reduce using rule 55 (sign -> MINUS .)
    LTE             reduce using rule 55 (sign -> MINUS .)
    GTE             reduce using rule 55 (sign -> MINUS .)
    THEN            reduce using rule 55 (sign -> MINUS .)
    AND             reduce using rule 55 (sign -> MINUS .)
    OR              reduce using rule 55 (sign -> MINUS .)
    DO              reduce using rule 55 (sign -> MINUS .)
    SEMICOLON       reduce using rule 55 (sign -> MINUS .)
    TO              reduce using rule 55 (sign -> MINUS .)
    DOWNTO          reduce using rule 55 (sign -> MINUS .)
    RPAREN          reduce using rule 55 (sign -> MINUS .)
    COMMA           reduce using rule 55 (sign -> MINUS .)


state 101

    (56) sign -> INT_DIV .

    BOOLEAN         reduce using rule 56 (sign -> INT_DIV .)
    NOT             reduce using rule 56 (sign -> INT_DIV .)
    LPAREN          reduce using rule 56 (sign -> INT_DIV .)
    IDENTIFIER      reduce using rule 56 (sign -> INT_DIV .)
    REAL            reduce using rule 56 (sign -> INT_DIV .)
    INTEGER         reduce using rule 56 (sign -> INT_DIV .)
    CHAR            reduce using rule 56 (sign -> INT_DIV .)
    STRING          reduce using rule 56 (sign -> INT_DIV .)
    PLUS            reduce using rule 56 (sign -> INT_DIV .)
    MINUS           reduce using rule 56 (sign -> INT_DIV .)
    INT_DIV         reduce using rule 56 (sign -> INT_DIV .)
    FLOAT_DIV       reduce using rule 56 (sign -> INT_DIV .)
    MULTIPLY        reduce using rule 56 (sign -> INT_DIV .)
    MOD             reduce using rule 56 (sign -> INT_DIV .)
    EQ              reduce using rule 56 (sign -> INT_DIV .)
    NEQ             reduce using rule 56 (sign -> INT_DIV .)
    LT              reduce using rule 56 (sign -> INT_DIV .)
    GT              reduce using rule 56 (sign -> INT_DIV .)
    LTE             reduce using rule 56 (sign -> INT_DIV .)
    GTE             reduce using rule 56 (sign -> INT_DIV .)
    THEN            reduce using rule 56 (sign -> INT_DIV .)
    AND             reduce using rule 56 (sign -> INT_DIV .)
    OR              reduce using rule 56 (sign -> INT_DIV .)
    DO              reduce using rule 56 (sign -> INT_DIV .)
    SEMICOLON       reduce using rule 56 (sign -> INT_DIV .)
    TO              reduce using rule 56 (sign -> INT_DIV .)
    DOWNTO          reduce using rule 56 (sign -> INT_DIV .)
    RPAREN          reduce using rule 56 (sign -> INT_DIV .)
    COMMA           reduce using rule 56 (sign -> INT_DIV .)


state 102

    (57) sign -> FLOAT_DIV .

    BOOLEAN         reduce using rule 57 (sign -> FLOAT_DIV .)
    NOT             reduce using rule 57 (sign -> FLOAT_DIV .)
    LPAREN          reduce using rule 57 (sign -> FLOAT_DIV .)
    IDENTIFIER      reduce using rule 57 (sign -> FLOAT_DIV .)
    REAL            reduce using rule 57 (sign -> FLOAT_DIV .)
    INTEGER         reduce using rule 57 (sign -> FLOAT_DIV .)
    CHAR            reduce using rule 57 (sign -> FLOAT_DIV .)
    STRING          reduce using rule 57 (sign -> FLOAT_DIV .)
    PLUS            reduce using rule 57 (sign -> FLOAT_DIV .)
    MINUS           reduce using rule 57 (sign -> FLOAT_DIV .)
    INT_DIV         reduce using rule 57 (sign -> FLOAT_DIV .)
    FLOAT_DIV       reduce using rule 57 (sign -> FLOAT_DIV .)
    MULTIPLY        reduce using rule 57 (sign -> FLOAT_DIV .)
    MOD             reduce using rule 57 (sign -> FLOAT_DIV .)
    EQ              reduce using rule 57 (sign -> FLOAT_DIV .)
    NEQ             reduce using rule 57 (sign -> FLOAT_DIV .)
    LT              reduce using rule 57 (sign -> FLOAT_DIV .)
    GT              reduce using rule 57 (sign -> FLOAT_DIV .)
    LTE             reduce using rule 57 (sign -> FLOAT_DIV .)
    GTE             reduce using rule 57 (sign -> FLOAT_DIV .)
    THEN            reduce using rule 57 (sign -> FLOAT_DIV .)
    AND             reduce using rule 57 (sign -> FLOAT_DIV .)
    OR              reduce using rule 57 (sign -> FLOAT_DIV .)
    DO              reduce using rule 57 (sign -> FLOAT_DIV .)
    SEMICOLON       reduce using rule 57 (sign -> FLOAT_DIV .)
    TO              reduce using rule 57 (sign -> FLOAT_DIV .)
    DOWNTO          reduce using rule 57 (sign -> FLOAT_DIV .)
    RPAREN          reduce using rule 57 (sign -> FLOAT_DIV .)
    COMMA           reduce using rule 57 (sign -> FLOAT_DIV .)


state 103

    (58) sign -> MULTIPLY .

    BOOLEAN         reduce using rule 58 (sign -> MULTIPLY .)
    NOT             reduce using rule 58 (sign -> MULTIPLY .)
    LPAREN          reduce using rule 58 (sign -> MULTIPLY .)
    IDENTIFIER      reduce using rule 58 (sign -> MULTIPLY .)
    REAL            reduce using rule 58 (sign -> MULTIPLY .)
    INTEGER         reduce using rule 58 (sign -> MULTIPLY .)
    CHAR            reduce using rule 58 (sign -> MULTIPLY .)
    STRING          reduce using rule 58 (sign -> MULTIPLY .)
    PLUS            reduce using rule 58 (sign -> MULTIPLY .)
    MINUS           reduce using rule 58 (sign -> MULTIPLY .)
    INT_DIV         reduce using rule 58 (sign -> MULTIPLY .)
    FLOAT_DIV       reduce using rule 58 (sign -> MULTIPLY .)
    MULTIPLY        reduce using rule 58 (sign -> MULTIPLY .)
    MOD             reduce using rule 58 (sign -> MULTIPLY .)
    EQ              reduce using rule 58 (sign -> MULTIPLY .)
    NEQ             reduce using rule 58 (sign -> MULTIPLY .)
    LT              reduce using rule 58 (sign -> MULTIPLY .)
    GT              reduce using rule 58 (sign -> MULTIPLY .)
    LTE             reduce using rule 58 (sign -> MULTIPLY .)
    GTE             reduce using rule 58 (sign -> MULTIPLY .)
    THEN            reduce using rule 58 (sign -> MULTIPLY .)
    AND             reduce using rule 58 (sign -> MULTIPLY .)
    OR              reduce using rule 58 (sign -> MULTIPLY .)
    DO              reduce using rule 58 (sign -> MULTIPLY .)
    SEMICOLON       reduce using rule 58 (sign -> MULTIPLY .)
    TO              reduce using rule 58 (sign -> MULTIPLY .)
    DOWNTO          reduce using rule 58 (sign -> MULTIPLY .)
    RPAREN          reduce using rule 58 (sign -> MULTIPLY .)
    COMMA           reduce using rule 58 (sign -> MULTIPLY .)


state 104

    (59) sign -> MOD .

    BOOLEAN         reduce using rule 59 (sign -> MOD .)
    NOT             reduce using rule 59 (sign -> MOD .)
    LPAREN          reduce using rule 59 (sign -> MOD .)
    IDENTIFIER      reduce using rule 59 (sign -> MOD .)
    REAL            reduce using rule 59 (sign -> MOD .)
    INTEGER         reduce using rule 59 (sign -> MOD .)
    CHAR            reduce using rule 59 (sign -> MOD .)
    STRING          reduce using rule 59 (sign -> MOD .)
    PLUS            reduce using rule 59 (sign -> MOD .)
    MINUS           reduce using rule 59 (sign -> MOD .)
    INT_DIV         reduce using rule 59 (sign -> MOD .)
    FLOAT_DIV       reduce using rule 59 (sign -> MOD .)
    MULTIPLY        reduce using rule 59 (sign -> MOD .)
    MOD             reduce using rule 59 (sign -> MOD .)
    EQ              reduce using rule 59 (sign -> MOD .)
    NEQ             reduce using rule 59 (sign -> MOD .)
    LT              reduce using rule 59 (sign -> MOD .)
    GT              reduce using rule 59 (sign -> MOD .)
    LTE             reduce using rule 59 (sign -> MOD .)
    GTE             reduce using rule 59 (sign -> MOD .)
    THEN            reduce using rule 59 (sign -> MOD .)
    AND             reduce using rule 59 (sign -> MOD .)
    OR              reduce using rule 59 (sign -> MOD .)
    DO              reduce using rule 59 (sign -> MOD .)
    SEMICOLON       reduce using rule 59 (sign -> MOD .)
    TO              reduce using rule 59 (sign -> MOD .)
    DOWNTO          reduce using rule 59 (sign -> MOD .)
    RPAREN          reduce using rule 59 (sign -> MOD .)
    COMMA           reduce using rule 59 (sign -> MOD .)


state 105

    (60) sign -> EQ .

    BOOLEAN         reduce using rule 60 (sign -> EQ .)
    NOT             reduce using rule 60 (sign -> EQ .)
    LPAREN          reduce using rule 60 (sign -> EQ .)
    IDENTIFIER      reduce using rule 60 (sign -> EQ .)
    REAL            reduce using rule 60 (sign -> EQ .)
    INTEGER         reduce using rule 60 (sign -> EQ .)
    CHAR            reduce using rule 60 (sign -> EQ .)
    STRING          reduce using rule 60 (sign -> EQ .)
    PLUS            reduce using rule 60 (sign -> EQ .)
    MINUS           reduce using rule 60 (sign -> EQ .)
    INT_DIV         reduce using rule 60 (sign -> EQ .)
    FLOAT_DIV       reduce using rule 60 (sign -> EQ .)
    MULTIPLY        reduce using rule 60 (sign -> EQ .)
    MOD             reduce using rule 60 (sign -> EQ .)
    EQ              reduce using rule 60 (sign -> EQ .)
    NEQ             reduce using rule 60 (sign -> EQ .)
    LT              reduce using rule 60 (sign -> EQ .)
    GT              reduce using rule 60 (sign -> EQ .)
    LTE             reduce using rule 60 (sign -> EQ .)
    GTE             reduce using rule 60 (sign -> EQ .)
    THEN            reduce using rule 60 (sign -> EQ .)
    AND             reduce using rule 60 (sign -> EQ .)
    OR              reduce using rule 60 (sign -> EQ .)
    DO              reduce using rule 60 (sign -> EQ .)
    SEMICOLON       reduce using rule 60 (sign -> EQ .)
    TO              reduce using rule 60 (sign -> EQ .)
    DOWNTO          reduce using rule 60 (sign -> EQ .)
    RPAREN          reduce using rule 60 (sign -> EQ .)
    COMMA           reduce using rule 60 (sign -> EQ .)


state 106

    (61) sign -> NEQ .

    BOOLEAN         reduce using rule 61 (sign -> NEQ .)
    NOT             reduce using rule 61 (sign -> NEQ .)
    LPAREN          reduce using rule 61 (sign -> NEQ .)
    IDENTIFIER      reduce using rule 61 (sign -> NEQ .)
    REAL            reduce using rule 61 (sign -> NEQ .)
    INTEGER         reduce using rule 61 (sign -> NEQ .)
    CHAR            reduce using rule 61 (sign -> NEQ .)
    STRING          reduce using rule 61 (sign -> NEQ .)
    PLUS            reduce using rule 61 (sign -> NEQ .)
    MINUS           reduce using rule 61 (sign -> NEQ .)
    INT_DIV         reduce using rule 61 (sign -> NEQ .)
    FLOAT_DIV       reduce using rule 61 (sign -> NEQ .)
    MULTIPLY        reduce using rule 61 (sign -> NEQ .)
    MOD             reduce using rule 61 (sign -> NEQ .)
    EQ              reduce using rule 61 (sign -> NEQ .)
    NEQ             reduce using rule 61 (sign -> NEQ .)
    LT              reduce using rule 61 (sign -> NEQ .)
    GT              reduce using rule 61 (sign -> NEQ .)
    LTE             reduce using rule 61 (sign -> NEQ .)
    GTE             reduce using rule 61 (sign -> NEQ .)
    THEN            reduce using rule 61 (sign -> NEQ .)
    AND             reduce using rule 61 (sign -> NEQ .)
    OR              reduce using rule 61 (sign -> NEQ .)
    DO              reduce using rule 61 (sign -> NEQ .)
    SEMICOLON       reduce using rule 61 (sign -> NEQ .)
    TO              reduce using rule 61 (sign -> NEQ .)
    DOWNTO          reduce using rule 61 (sign -> NEQ .)
    RPAREN          reduce using rule 61 (sign -> NEQ .)
    COMMA           reduce using rule 61 (sign -> NEQ .)


state 107

    (62) sign -> LT .

    BOOLEAN         reduce using rule 62 (sign -> LT .)
    NOT             reduce using rule 62 (sign -> LT .)
    LPAREN          reduce using rule 62 (sign -> LT .)
    IDENTIFIER      reduce using rule 62 (sign -> LT .)
    REAL            reduce using rule 62 (sign -> LT .)
    INTEGER         reduce using rule 62 (sign -> LT .)
    CHAR            reduce using rule 62 (sign -> LT .)
    STRING          reduce using rule 62 (sign -> LT .)
    PLUS            reduce using rule 62 (sign -> LT .)
    MINUS           reduce using rule 62 (sign -> LT .)
    INT_DIV         reduce using rule 62 (sign -> LT .)
    FLOAT_DIV       reduce using rule 62 (sign -> LT .)
    MULTIPLY        reduce using rule 62 (sign -> LT .)
    MOD             reduce using rule 62 (sign -> LT .)
    EQ              reduce using rule 62 (sign -> LT .)
    NEQ             reduce using rule 62 (sign -> LT .)
    LT              reduce using rule 62 (sign -> LT .)
    GT              reduce using rule 62 (sign -> LT .)
    LTE             reduce using rule 62 (sign -> LT .)
    GTE             reduce using rule 62 (sign -> LT .)
    THEN            reduce using rule 62 (sign -> LT .)
    AND             reduce using rule 62 (sign -> LT .)
    OR              reduce using rule 62 (sign -> LT .)
    DO              reduce using rule 62 (sign -> LT .)
    SEMICOLON       reduce using rule 62 (sign -> LT .)
    TO              reduce using rule 62 (sign -> LT .)
    DOWNTO          reduce using rule 62 (sign -> LT .)
    RPAREN          reduce using rule 62 (sign -> LT .)
    COMMA           reduce using rule 62 (sign -> LT .)


state 108

    (63) sign -> GT .

    BOOLEAN         reduce using rule 63 (sign -> GT .)
    NOT             reduce using rule 63 (sign -> GT .)
    LPAREN          reduce using rule 63 (sign -> GT .)
    IDENTIFIER      reduce using rule 63 (sign -> GT .)
    REAL            reduce using rule 63 (sign -> GT .)
    INTEGER         reduce using rule 63 (sign -> GT .)
    CHAR            reduce using rule 63 (sign -> GT .)
    STRING          reduce using rule 63 (sign -> GT .)
    PLUS            reduce using rule 63 (sign -> GT .)
    MINUS           reduce using rule 63 (sign -> GT .)
    INT_DIV         reduce using rule 63 (sign -> GT .)
    FLOAT_DIV       reduce using rule 63 (sign -> GT .)
    MULTIPLY        reduce using rule 63 (sign -> GT .)
    MOD             reduce using rule 63 (sign -> GT .)
    EQ              reduce using rule 63 (sign -> GT .)
    NEQ             reduce using rule 63 (sign -> GT .)
    LT              reduce using rule 63 (sign -> GT .)
    GT              reduce using rule 63 (sign -> GT .)
    LTE             reduce using rule 63 (sign -> GT .)
    GTE             reduce using rule 63 (sign -> GT .)
    THEN            reduce using rule 63 (sign -> GT .)
    AND             reduce using rule 63 (sign -> GT .)
    OR              reduce using rule 63 (sign -> GT .)
    DO              reduce using rule 63 (sign -> GT .)
    SEMICOLON       reduce using rule 63 (sign -> GT .)
    TO              reduce using rule 63 (sign -> GT .)
    DOWNTO          reduce using rule 63 (sign -> GT .)
    RPAREN          reduce using rule 63 (sign -> GT .)
    COMMA           reduce using rule 63 (sign -> GT .)


state 109

    (64) sign -> LTE .

    BOOLEAN         reduce using rule 64 (sign -> LTE .)
    NOT             reduce using rule 64 (sign -> LTE .)
    LPAREN          reduce using rule 64 (sign -> LTE .)
    IDENTIFIER      reduce using rule 64 (sign -> LTE .)
    REAL            reduce using rule 64 (sign -> LTE .)
    INTEGER         reduce using rule 64 (sign -> LTE .)
    CHAR            reduce using rule 64 (sign -> LTE .)
    STRING          reduce using rule 64 (sign -> LTE .)
    PLUS            reduce using rule 64 (sign -> LTE .)
    MINUS           reduce using rule 64 (sign -> LTE .)
    INT_DIV         reduce using rule 64 (sign -> LTE .)
    FLOAT_DIV       reduce using rule 64 (sign -> LTE .)
    MULTIPLY        reduce using rule 64 (sign -> LTE .)
    MOD             reduce using rule 64 (sign -> LTE .)
    EQ              reduce using rule 64 (sign -> LTE .)
    NEQ             reduce using rule 64 (sign -> LTE .)
    LT              reduce using rule 64 (sign -> LTE .)
    GT              reduce using rule 64 (sign -> LTE .)
    LTE             reduce using rule 64 (sign -> LTE .)
    GTE             reduce using rule 64 (sign -> LTE .)
    THEN            reduce using rule 64 (sign -> LTE .)
    AND             reduce using rule 64 (sign -> LTE .)
    OR              reduce using rule 64 (sign -> LTE .)
    DO              reduce using rule 64 (sign -> LTE .)
    SEMICOLON       reduce using rule 64 (sign -> LTE .)
    TO              reduce using rule 64 (sign -> LTE .)
    DOWNTO          reduce using rule 64 (sign -> LTE .)
    RPAREN          reduce using rule 64 (sign -> LTE .)
    COMMA           reduce using rule 64 (sign -> LTE .)


state 110

    (65) sign -> GTE .

    BOOLEAN         reduce using rule 65 (sign -> GTE .)
    NOT             reduce using rule 65 (sign -> GTE .)
    LPAREN          reduce using rule 65 (sign -> GTE .)
    IDENTIFIER      reduce using rule 65 (sign -> GTE .)
    REAL            reduce using rule 65 (sign -> GTE .)
    INTEGER         reduce using rule 65 (sign -> GTE .)
    CHAR            reduce using rule 65 (sign -> GTE .)
    STRING          reduce using rule 65 (sign -> GTE .)
    PLUS            reduce using rule 65 (sign -> GTE .)
    MINUS           reduce using rule 65 (sign -> GTE .)
    INT_DIV         reduce using rule 65 (sign -> GTE .)
    FLOAT_DIV       reduce using rule 65 (sign -> GTE .)
    MULTIPLY        reduce using rule 65 (sign -> GTE .)
    MOD             reduce using rule 65 (sign -> GTE .)
    EQ              reduce using rule 65 (sign -> GTE .)
    NEQ             reduce using rule 65 (sign -> GTE .)
    LT              reduce using rule 65 (sign -> GTE .)
    GT              reduce using rule 65 (sign -> GTE .)
    LTE             reduce using rule 65 (sign -> GTE .)
    GTE             reduce using rule 65 (sign -> GTE .)
    THEN            reduce using rule 65 (sign -> GTE .)
    AND             reduce using rule 65 (sign -> GTE .)
    OR              reduce using rule 65 (sign -> GTE .)
    DO              reduce using rule 65 (sign -> GTE .)
    SEMICOLON       reduce using rule 65 (sign -> GTE .)
    TO              reduce using rule 65 (sign -> GTE .)
    DOWNTO          reduce using rule 65 (sign -> GTE .)
    RPAREN          reduce using rule 65 (sign -> GTE .)
    COMMA           reduce using rule 65 (sign -> GTE .)


state 111

    (67) element -> NOT element .

    PLUS            reduce using rule 67 (element -> NOT element .)
    MINUS           reduce using rule 67 (element -> NOT element .)
    INT_DIV         reduce using rule 67 (element -> NOT element .)
    FLOAT_DIV       reduce using rule 67 (element -> NOT element .)
    MULTIPLY        reduce using rule 67 (element -> NOT element .)
    MOD             reduce using rule 67 (element -> NOT element .)
    EQ              reduce using rule 67 (element -> NOT element .)
    NEQ             reduce using rule 67 (element -> NOT element .)
    LT              reduce using rule 67 (element -> NOT element .)
    GT              reduce using rule 67 (element -> NOT element .)
    LTE             reduce using rule 67 (element -> NOT element .)
    GTE             reduce using rule 67 (element -> NOT element .)
    THEN            reduce using rule 67 (element -> NOT element .)
    AND             reduce using rule 67 (element -> NOT element .)
    OR              reduce using rule 67 (element -> NOT element .)
    DO              reduce using rule 67 (element -> NOT element .)
    SEMICOLON       reduce using rule 67 (element -> NOT element .)
    TO              reduce using rule 67 (element -> NOT element .)
    DOWNTO          reduce using rule 67 (element -> NOT element .)
    RPAREN          reduce using rule 67 (element -> NOT element .)
    COMMA           reduce using rule 67 (element -> NOT element .)


state 112

    (76) function_call -> identifier LPAREN . variables_list RPAREN
    (39) variables_list -> . variables_list COMMA expression
    (40) variables_list -> . expression
    (48) expression -> . expression and_or expression_m
    (49) expression -> . expression_m
    (50) expression_m -> . element
    (51) expression_m -> . expression_m sign element
    (66) element -> . BOOLEAN
    (67) element -> . NOT element
    (68) element -> . identifier
    (69) element -> . real
    (70) element -> . integer
    (71) element -> . char
    (72) element -> . string
    (73) element -> . LPAREN expression RPAREN
    (74) element -> . function_call
    (75) element -> . empty
    (77) identifier -> . IDENTIFIER
    (78) real -> . REAL
    (79) integer -> . INTEGER
    (81) char -> . CHAR
    (80) string -> . STRING
    (76) function_call -> . identifier LPAREN variables_list RPAREN
    (1) empty -> .

    BOOLEAN         shift and go to state 65
    NOT             shift and go to state 66
    LPAREN          shift and go to state 72
    IDENTIFIER      shift and go to state 4
    REAL            shift and go to state 75
    INTEGER         shift and go to state 76
    CHAR            shift and go to state 77
    STRING          shift and go to state 78
    PLUS            reduce using rule 1 (empty -> .)
    MINUS           reduce using rule 1 (empty -> .)
    INT_DIV         reduce using rule 1 (empty -> .)
    FLOAT_DIV       reduce using rule 1 (empty -> .)
    MULTIPLY        reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    EQ              reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    LTE             reduce using rule 1 (empty -> .)
    GTE             reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    RPAREN          reduce using rule 1 (empty -> .)
    COMMA           reduce using rule 1 (empty -> .)

    identifier                     shift and go to state 67
    variables_list                 shift and go to state 128
    expression                     shift and go to state 93
    expression_m                   shift and go to state 63
    element                        shift and go to state 64
    real                           shift and go to state 68
    integer                        shift and go to state 69
    char                           shift and go to state 70
    string                         shift and go to state 71
    function_call                  shift and go to state 73
    empty                          shift and go to state 74

state 113

    (73) element -> LPAREN expression . RPAREN
    (48) expression -> expression . and_or expression_m
    (52) and_or -> . AND
    (53) and_or -> . OR

    RPAREN          shift and go to state 129
    AND             shift and go to state 96
    OR              shift and go to state 97

    and_or                         shift and go to state 95

state 114

    (44) while_statement -> WHILE expression DO . statement
    (30) statement -> . compound_statement
    (31) statement -> . assignment_statement
    (32) statement -> . if_statement
    (33) statement -> . while_statement
    (34) statement -> . repeat_statement
    (35) statement -> . for_statement
    (36) statement -> . procedure_or_function_call
    (27) compound_statement -> . BEGIN statement_sequence END
    (41) assignment_statement -> . identifier ASSIGNMENT expression
    (42) if_statement -> . IF expression THEN compound_statement
    (43) if_statement -> . IF expression THEN compound_statement ELSE compound_statement
    (44) while_statement -> . WHILE expression DO statement
    (45) repeat_statement -> . REPEAT statement_sequence UNTIL expression
    (46) for_statement -> . FOR assignment_statement TO expression DO statement
    (47) for_statement -> . FOR assignment_statement DOWNTO expression DO statement
    (37) procedure_or_function_call -> . identifier
    (38) procedure_or_function_call -> . identifier LPAREN variables_list RPAREN
    (77) identifier -> . IDENTIFIER

    BEGIN           shift and go to state 22
    IF              shift and go to state 41
    WHILE           shift and go to state 42
    REPEAT          shift and go to state 43
    FOR             shift and go to state 44
    IDENTIFIER      shift and go to state 4

    statement                      shift and go to state 130
    compound_statement             shift and go to state 33
    assignment_statement           shift and go to state 34
    if_statement                   shift and go to state 35
    while_statement                shift and go to state 36
    repeat_statement               shift and go to state 37
    for_statement                  shift and go to state 38
    procedure_or_function_call     shift and go to state 39
    identifier                     shift and go to state 40

state 115

    (45) repeat_statement -> REPEAT statement_sequence UNTIL . expression
    (48) expression -> . expression and_or expression_m
    (49) expression -> . expression_m
    (50) expression_m -> . element
    (51) expression_m -> . expression_m sign element
    (66) element -> . BOOLEAN
    (67) element -> . NOT element
    (68) element -> . identifier
    (69) element -> . real
    (70) element -> . integer
    (71) element -> . char
    (72) element -> . string
    (73) element -> . LPAREN expression RPAREN
    (74) element -> . function_call
    (75) element -> . empty
    (77) identifier -> . IDENTIFIER
    (78) real -> . REAL
    (79) integer -> . INTEGER
    (81) char -> . CHAR
    (80) string -> . STRING
    (76) function_call -> . identifier LPAREN variables_list RPAREN
    (1) empty -> .

    BOOLEAN         shift and go to state 65
    NOT             shift and go to state 66
    LPAREN          shift and go to state 72
    IDENTIFIER      shift and go to state 4
    REAL            shift and go to state 75
    INTEGER         shift and go to state 76
    CHAR            shift and go to state 77
    STRING          shift and go to state 78
    PLUS            reduce using rule 1 (empty -> .)
    MINUS           reduce using rule 1 (empty -> .)
    INT_DIV         reduce using rule 1 (empty -> .)
    FLOAT_DIV       reduce using rule 1 (empty -> .)
    MULTIPLY        reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    EQ              reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    LTE             reduce using rule 1 (empty -> .)
    GTE             reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    SEMICOLON       reduce using rule 1 (empty -> .)

    expression                     shift and go to state 131
    expression_m                   shift and go to state 63
    element                        shift and go to state 64
    identifier                     shift and go to state 67
    real                           shift and go to state 68
    integer                        shift and go to state 69
    char                           shift and go to state 70
    string                         shift and go to state 71
    function_call                  shift and go to state 73
    empty                          shift and go to state 74

state 116

    (46) for_statement -> FOR assignment_statement TO . expression DO statement
    (48) expression -> . expression and_or expression_m
    (49) expression -> . expression_m
    (50) expression_m -> . element
    (51) expression_m -> . expression_m sign element
    (66) element -> . BOOLEAN
    (67) element -> . NOT element
    (68) element -> . identifier
    (69) element -> . real
    (70) element -> . integer
    (71) element -> . char
    (72) element -> . string
    (73) element -> . LPAREN expression RPAREN
    (74) element -> . function_call
    (75) element -> . empty
    (77) identifier -> . IDENTIFIER
    (78) real -> . REAL
    (79) integer -> . INTEGER
    (81) char -> . CHAR
    (80) string -> . STRING
    (76) function_call -> . identifier LPAREN variables_list RPAREN
    (1) empty -> .

    BOOLEAN         shift and go to state 65
    NOT             shift and go to state 66
    LPAREN          shift and go to state 72
    IDENTIFIER      shift and go to state 4
    REAL            shift and go to state 75
    INTEGER         shift and go to state 76
    CHAR            shift and go to state 77
    STRING          shift and go to state 78
    PLUS            reduce using rule 1 (empty -> .)
    MINUS           reduce using rule 1 (empty -> .)
    INT_DIV         reduce using rule 1 (empty -> .)
    FLOAT_DIV       reduce using rule 1 (empty -> .)
    MULTIPLY        reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    EQ              reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    LTE             reduce using rule 1 (empty -> .)
    GTE             reduce using rule 1 (empty -> .)
    DO              reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)

    expression                     shift and go to state 132
    expression_m                   shift and go to state 63
    element                        shift and go to state 64
    identifier                     shift and go to state 67
    real                           shift and go to state 68
    integer                        shift and go to state 69
    char                           shift and go to state 70
    string                         shift and go to state 71
    function_call                  shift and go to state 73
    empty                          shift and go to state 74

state 117

    (47) for_statement -> FOR assignment_statement DOWNTO . expression DO statement
    (48) expression -> . expression and_or expression_m
    (49) expression -> . expression_m
    (50) expression_m -> . element
    (51) expression_m -> . expression_m sign element
    (66) element -> . BOOLEAN
    (67) element -> . NOT element
    (68) element -> . identifier
    (69) element -> . real
    (70) element -> . integer
    (71) element -> . char
    (72) element -> . string
    (73) element -> . LPAREN expression RPAREN
    (74) element -> . function_call
    (75) element -> . empty
    (77) identifier -> . IDENTIFIER
    (78) real -> . REAL
    (79) integer -> . INTEGER
    (81) char -> . CHAR
    (80) string -> . STRING
    (76) function_call -> . identifier LPAREN variables_list RPAREN
    (1) empty -> .

    BOOLEAN         shift and go to state 65
    NOT             shift and go to state 66
    LPAREN          shift and go to state 72
    IDENTIFIER      shift and go to state 4
    REAL            shift and go to state 75
    INTEGER         shift and go to state 76
    CHAR            shift and go to state 77
    STRING          shift and go to state 78
    PLUS            reduce using rule 1 (empty -> .)
    MINUS           reduce using rule 1 (empty -> .)
    INT_DIV         reduce using rule 1 (empty -> .)
    FLOAT_DIV       reduce using rule 1 (empty -> .)
    MULTIPLY        reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    EQ              reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    LTE             reduce using rule 1 (empty -> .)
    GTE             reduce using rule 1 (empty -> .)
    DO              reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)

    expression                     shift and go to state 133
    expression_m                   shift and go to state 63
    element                        shift and go to state 64
    identifier                     shift and go to state 67
    real                           shift and go to state 68
    integer                        shift and go to state 69
    char                           shift and go to state 70
    string                         shift and go to state 71
    function_call                  shift and go to state 73
    empty                          shift and go to state 74

state 118

    (3) block -> variable_declaration_part procedure_or_function compound_statement .

    SEMICOLON       reduce using rule 3 (block -> variable_declaration_part procedure_or_function compound_statement .)


state 119

    (23) parameter -> identifier COLON . type
    (9) type -> . SINTEGER
    (10) type -> . SCHAR
    (11) type -> . SREAL
    (12) type -> . SSTRING
    (13) type -> . SBOOLEAN

    SINTEGER        shift and go to state 53
    SCHAR           shift and go to state 54
    SREAL           shift and go to state 55
    SSTRING         shift and go to state 56
    SBOOLEAN        shift and go to state 57

    type                           shift and go to state 134

state 120

    (26) procedure_heading -> PROCEDURE identifier LPAREN parameters_list RPAREN .

    SEMICOLON       reduce using rule 26 (procedure_heading -> PROCEDURE identifier LPAREN parameters_list RPAREN .)


state 121

    (21) parameters_list -> parameter COMMA . parameters_list
    (21) parameters_list -> . parameter COMMA parameters_list
    (22) parameters_list -> . parameter
    (23) parameter -> . identifier COLON type
    (77) identifier -> . IDENTIFIER

    IDENTIFIER      shift and go to state 4

    parameter                      shift and go to state 86
    parameters_list                shift and go to state 135
    identifier                     shift and go to state 84

state 122

    (20) function_heading -> FUNCTION identifier LPAREN parameters_list RPAREN . COLON type

    COLON           shift and go to state 136


state 123

    (38) procedure_or_function_call -> identifier LPAREN variables_list RPAREN .

    SEMICOLON       reduce using rule 38 (procedure_or_function_call -> identifier LPAREN variables_list RPAREN .)


state 124

    (39) variables_list -> variables_list COMMA . expression
    (48) expression -> . expression and_or expression_m
    (49) expression -> . expression_m
    (50) expression_m -> . element
    (51) expression_m -> . expression_m sign element
    (66) element -> . BOOLEAN
    (67) element -> . NOT element
    (68) element -> . identifier
    (69) element -> . real
    (70) element -> . integer
    (71) element -> . char
    (72) element -> . string
    (73) element -> . LPAREN expression RPAREN
    (74) element -> . function_call
    (75) element -> . empty
    (77) identifier -> . IDENTIFIER
    (78) real -> . REAL
    (79) integer -> . INTEGER
    (81) char -> . CHAR
    (80) string -> . STRING
    (76) function_call -> . identifier LPAREN variables_list RPAREN
    (1) empty -> .

    BOOLEAN         shift and go to state 65
    NOT             shift and go to state 66
    LPAREN          shift and go to state 72
    IDENTIFIER      shift and go to state 4
    REAL            shift and go to state 75
    INTEGER         shift and go to state 76
    CHAR            shift and go to state 77
    STRING          shift and go to state 78
    PLUS            reduce using rule 1 (empty -> .)
    MINUS           reduce using rule 1 (empty -> .)
    INT_DIV         reduce using rule 1 (empty -> .)
    FLOAT_DIV       reduce using rule 1 (empty -> .)
    MULTIPLY        reduce using rule 1 (empty -> .)
    MOD             reduce using rule 1 (empty -> .)
    EQ              reduce using rule 1 (empty -> .)
    NEQ             reduce using rule 1 (empty -> .)
    LT              reduce using rule 1 (empty -> .)
    GT              reduce using rule 1 (empty -> .)
    LTE             reduce using rule 1 (empty -> .)
    GTE             reduce using rule 1 (empty -> .)
    AND             reduce using rule 1 (empty -> .)
    OR              reduce using rule 1 (empty -> .)
    RPAREN          reduce using rule 1 (empty -> .)
    COMMA           reduce using rule 1 (empty -> .)

    expression                     shift and go to state 137
    expression_m                   shift and go to state 63
    element                        shift and go to state 64
    identifier                     shift and go to state 67
    real                           shift and go to state 68
    integer                        shift and go to state 69
    char                           shift and go to state 70
    string                         shift and go to state 71
    function_call                  shift and go to state 73
    empty                          shift and go to state 74

state 125

    (42) if_statement -> IF expression THEN compound_statement .
    (43) if_statement -> IF expression THEN compound_statement . ELSE compound_statement

    SEMICOLON       reduce using rule 42 (if_statement -> IF expression THEN compound_statement .)
    ELSE            shift and go to state 138


state 126

    (48) expression -> expression and_or expression_m .
    (51) expression_m -> expression_m . sign element
    (54) sign -> . PLUS
    (55) sign -> . MINUS
    (56) sign -> . INT_DIV
    (57) sign -> . FLOAT_DIV
    (58) sign -> . MULTIPLY
    (59) sign -> . MOD
    (60) sign -> . EQ
    (61) sign -> . NEQ
    (62) sign -> . LT
    (63) sign -> . GT
    (64) sign -> . LTE
    (65) sign -> . GTE

    THEN            reduce using rule 48 (expression -> expression and_or expression_m .)
    AND             reduce using rule 48 (expression -> expression and_or expression_m .)
    OR              reduce using rule 48 (expression -> expression and_or expression_m .)
    DO              reduce using rule 48 (expression -> expression and_or expression_m .)
    SEMICOLON       reduce using rule 48 (expression -> expression and_or expression_m .)
    TO              reduce using rule 48 (expression -> expression and_or expression_m .)
    DOWNTO          reduce using rule 48 (expression -> expression and_or expression_m .)
    RPAREN          reduce using rule 48 (expression -> expression and_or expression_m .)
    COMMA           reduce using rule 48 (expression -> expression and_or expression_m .)
    PLUS            shift and go to state 99
    MINUS           shift and go to state 100
    INT_DIV         shift and go to state 101
    FLOAT_DIV       shift and go to state 102
    MULTIPLY        shift and go to state 103
    MOD             shift and go to state 104
    EQ              shift and go to state 105
    NEQ             shift and go to state 106
    LT              shift and go to state 107
    GT              shift and go to state 108
    LTE             shift and go to state 109
    GTE             shift and go to state 110

    sign                           shift and go to state 98

state 127

    (51) expression_m -> expression_m sign element .

    PLUS            reduce using rule 51 (expression_m -> expression_m sign element .)
    MINUS           reduce using rule 51 (expression_m -> expression_m sign element .)
    INT_DIV         reduce using rule 51 (expression_m -> expression_m sign element .)
    FLOAT_DIV       reduce using rule 51 (expression_m -> expression_m sign element .)
    MULTIPLY        reduce using rule 51 (expression_m -> expression_m sign element .)
    MOD             reduce using rule 51 (expression_m -> expression_m sign element .)
    EQ              reduce using rule 51 (expression_m -> expression_m sign element .)
    NEQ             reduce using rule 51 (expression_m -> expression_m sign element .)
    LT              reduce using rule 51 (expression_m -> expression_m sign element .)
    GT              reduce using rule 51 (expression_m -> expression_m sign element .)
    LTE             reduce using rule 51 (expression_m -> expression_m sign element .)
    GTE             reduce using rule 51 (expression_m -> expression_m sign element .)
    THEN            reduce using rule 51 (expression_m -> expression_m sign element .)
    AND             reduce using rule 51 (expression_m -> expression_m sign element .)
    OR              reduce using rule 51 (expression_m -> expression_m sign element .)
    DO              reduce using rule 51 (expression_m -> expression_m sign element .)
    SEMICOLON       reduce using rule 51 (expression_m -> expression_m sign element .)
    TO              reduce using rule 51 (expression_m -> expression_m sign element .)
    DOWNTO          reduce using rule 51 (expression_m -> expression_m sign element .)
    RPAREN          reduce using rule 51 (expression_m -> expression_m sign element .)
    COMMA           reduce using rule 51 (expression_m -> expression_m sign element .)


state 128

    (76) function_call -> identifier LPAREN variables_list . RPAREN
    (39) variables_list -> variables_list . COMMA expression

    RPAREN          shift and go to state 139
    COMMA           shift and go to state 124


state 129

    (73) element -> LPAREN expression RPAREN .

    PLUS            reduce using rule 73 (element -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 73 (element -> LPAREN expression RPAREN .)
    INT_DIV         reduce using rule 73 (element -> LPAREN expression RPAREN .)
    FLOAT_DIV       reduce using rule 73 (element -> LPAREN expression RPAREN .)
    MULTIPLY        reduce using rule 73 (element -> LPAREN expression RPAREN .)
    MOD             reduce using rule 73 (element -> LPAREN expression RPAREN .)
    EQ              reduce using rule 73 (element -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 73 (element -> LPAREN expression RPAREN .)
    LT              reduce using rule 73 (element -> LPAREN expression RPAREN .)
    GT              reduce using rule 73 (element -> LPAREN expression RPAREN .)
    LTE             reduce using rule 73 (element -> LPAREN expression RPAREN .)
    GTE             reduce using rule 73 (element -> LPAREN expression RPAREN .)
    THEN            reduce using rule 73 (element -> LPAREN expression RPAREN .)
    AND             reduce using rule 73 (element -> LPAREN expression RPAREN .)
    OR              reduce using rule 73 (element -> LPAREN expression RPAREN .)
    DO              reduce using rule 73 (element -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 73 (element -> LPAREN expression RPAREN .)
    TO              reduce using rule 73 (element -> LPAREN expression RPAREN .)
    DOWNTO          reduce using rule 73 (element -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 73 (element -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 73 (element -> LPAREN expression RPAREN .)


state 130

    (44) while_statement -> WHILE expression DO statement .

    SEMICOLON       reduce using rule 44 (while_statement -> WHILE expression DO statement .)


state 131

    (45) repeat_statement -> REPEAT statement_sequence UNTIL expression .
    (48) expression -> expression . and_or expression_m
    (52) and_or -> . AND
    (53) and_or -> . OR

    SEMICOLON       reduce using rule 45 (repeat_statement -> REPEAT statement_sequence UNTIL expression .)
    AND             shift and go to state 96
    OR              shift and go to state 97

    and_or                         shift and go to state 95

state 132

    (46) for_statement -> FOR assignment_statement TO expression . DO statement
    (48) expression -> expression . and_or expression_m
    (52) and_or -> . AND
    (53) and_or -> . OR

    DO              shift and go to state 140
    AND             shift and go to state 96
    OR              shift and go to state 97

    and_or                         shift and go to state 95

state 133

    (47) for_statement -> FOR assignment_statement DOWNTO expression . DO statement
    (48) expression -> expression . and_or expression_m
    (52) and_or -> . AND
    (53) and_or -> . OR

    DO              shift and go to state 141
    AND             shift and go to state 96
    OR              shift and go to state 97

    and_or                         shift and go to state 95

state 134

    (23) parameter -> identifier COLON type .

    COMMA           reduce using rule 23 (parameter -> identifier COLON type .)
    RPAREN          reduce using rule 23 (parameter -> identifier COLON type .)


state 135

    (21) parameters_list -> parameter COMMA parameters_list .

    RPAREN          reduce using rule 21 (parameters_list -> parameter COMMA parameters_list .)


state 136

    (20) function_heading -> FUNCTION identifier LPAREN parameters_list RPAREN COLON . type
    (9) type -> . SINTEGER
    (10) type -> . SCHAR
    (11) type -> . SREAL
    (12) type -> . SSTRING
    (13) type -> . SBOOLEAN

    SINTEGER        shift and go to state 53
    SCHAR           shift and go to state 54
    SREAL           shift and go to state 55
    SSTRING         shift and go to state 56
    SBOOLEAN        shift and go to state 57

    type                           shift and go to state 142

state 137

    (39) variables_list -> variables_list COMMA expression .
    (48) expression -> expression . and_or expression_m
    (52) and_or -> . AND
    (53) and_or -> . OR

    RPAREN          reduce using rule 39 (variables_list -> variables_list COMMA expression .)
    COMMA           reduce using rule 39 (variables_list -> variables_list COMMA expression .)
    AND             shift and go to state 96
    OR              shift and go to state 97

    and_or                         shift and go to state 95

state 138

    (43) if_statement -> IF expression THEN compound_statement ELSE . compound_statement
    (27) compound_statement -> . BEGIN statement_sequence END

    BEGIN           shift and go to state 22

    compound_statement             shift and go to state 143

state 139

    (76) function_call -> identifier LPAREN variables_list RPAREN .

    PLUS            reduce using rule 76 (function_call -> identifier LPAREN variables_list RPAREN .)
    MINUS           reduce using rule 76 (function_call -> identifier LPAREN variables_list RPAREN .)
    INT_DIV         reduce using rule 76 (function_call -> identifier LPAREN variables_list RPAREN .)
    FLOAT_DIV       reduce using rule 76 (function_call -> identifier LPAREN variables_list RPAREN .)
    MULTIPLY        reduce using rule 76 (function_call -> identifier LPAREN variables_list RPAREN .)
    MOD             reduce using rule 76 (function_call -> identifier LPAREN variables_list RPAREN .)
    EQ              reduce using rule 76 (function_call -> identifier LPAREN variables_list RPAREN .)
    NEQ             reduce using rule 76 (function_call -> identifier LPAREN variables_list RPAREN .)
    LT              reduce using rule 76 (function_call -> identifier LPAREN variables_list RPAREN .)
    GT              reduce using rule 76 (function_call -> identifier LPAREN variables_list RPAREN .)
    LTE             reduce using rule 76 (function_call -> identifier LPAREN variables_list RPAREN .)
    GTE             reduce using rule 76 (function_call -> identifier LPAREN variables_list RPAREN .)
    THEN            reduce using rule 76 (function_call -> identifier LPAREN variables_list RPAREN .)
    AND             reduce using rule 76 (function_call -> identifier LPAREN variables_list RPAREN .)
    OR              reduce using rule 76 (function_call -> identifier LPAREN variables_list RPAREN .)
    DO              reduce using rule 76 (function_call -> identifier LPAREN variables_list RPAREN .)
    SEMICOLON       reduce using rule 76 (function_call -> identifier LPAREN variables_list RPAREN .)
    TO              reduce using rule 76 (function_call -> identifier LPAREN variables_list RPAREN .)
    DOWNTO          reduce using rule 76 (function_call -> identifier LPAREN variables_list RPAREN .)
    RPAREN          reduce using rule 76 (function_call -> identifier LPAREN variables_list RPAREN .)
    COMMA           reduce using rule 76 (function_call -> identifier LPAREN variables_list RPAREN .)


state 140

    (46) for_statement -> FOR assignment_statement TO expression DO . statement
    (30) statement -> . compound_statement
    (31) statement -> . assignment_statement
    (32) statement -> . if_statement
    (33) statement -> . while_statement
    (34) statement -> . repeat_statement
    (35) statement -> . for_statement
    (36) statement -> . procedure_or_function_call
    (27) compound_statement -> . BEGIN statement_sequence END
    (41) assignment_statement -> . identifier ASSIGNMENT expression
    (42) if_statement -> . IF expression THEN compound_statement
    (43) if_statement -> . IF expression THEN compound_statement ELSE compound_statement
    (44) while_statement -> . WHILE expression DO statement
    (45) repeat_statement -> . REPEAT statement_sequence UNTIL expression
    (46) for_statement -> . FOR assignment_statement TO expression DO statement
    (47) for_statement -> . FOR assignment_statement DOWNTO expression DO statement
    (37) procedure_or_function_call -> . identifier
    (38) procedure_or_function_call -> . identifier LPAREN variables_list RPAREN
    (77) identifier -> . IDENTIFIER

    BEGIN           shift and go to state 22
    IF              shift and go to state 41
    WHILE           shift and go to state 42
    REPEAT          shift and go to state 43
    FOR             shift and go to state 44
    IDENTIFIER      shift and go to state 4

    assignment_statement           shift and go to state 34
    statement                      shift and go to state 144
    compound_statement             shift and go to state 33
    if_statement                   shift and go to state 35
    while_statement                shift and go to state 36
    repeat_statement               shift and go to state 37
    for_statement                  shift and go to state 38
    procedure_or_function_call     shift and go to state 39
    identifier                     shift and go to state 40

state 141

    (47) for_statement -> FOR assignment_statement DOWNTO expression DO . statement
    (30) statement -> . compound_statement
    (31) statement -> . assignment_statement
    (32) statement -> . if_statement
    (33) statement -> . while_statement
    (34) statement -> . repeat_statement
    (35) statement -> . for_statement
    (36) statement -> . procedure_or_function_call
    (27) compound_statement -> . BEGIN statement_sequence END
    (41) assignment_statement -> . identifier ASSIGNMENT expression
    (42) if_statement -> . IF expression THEN compound_statement
    (43) if_statement -> . IF expression THEN compound_statement ELSE compound_statement
    (44) while_statement -> . WHILE expression DO statement
    (45) repeat_statement -> . REPEAT statement_sequence UNTIL expression
    (46) for_statement -> . FOR assignment_statement TO expression DO statement
    (47) for_statement -> . FOR assignment_statement DOWNTO expression DO statement
    (37) procedure_or_function_call -> . identifier
    (38) procedure_or_function_call -> . identifier LPAREN variables_list RPAREN
    (77) identifier -> . IDENTIFIER

    BEGIN           shift and go to state 22
    IF              shift and go to state 41
    WHILE           shift and go to state 42
    REPEAT          shift and go to state 43
    FOR             shift and go to state 44
    IDENTIFIER      shift and go to state 4

    assignment_statement           shift and go to state 34
    statement                      shift and go to state 145
    compound_statement             shift and go to state 33
    if_statement                   shift and go to state 35
    while_statement                shift and go to state 36
    repeat_statement               shift and go to state 37
    for_statement                  shift and go to state 38
    procedure_or_function_call     shift and go to state 39
    identifier                     shift and go to state 40

state 142

    (20) function_heading -> FUNCTION identifier LPAREN parameters_list RPAREN COLON type .

    SEMICOLON       reduce using rule 20 (function_heading -> FUNCTION identifier LPAREN parameters_list RPAREN COLON type .)


state 143

    (43) if_statement -> IF expression THEN compound_statement ELSE compound_statement .

    SEMICOLON       reduce using rule 43 (if_statement -> IF expression THEN compound_statement ELSE compound_statement .)


state 144

    (46) for_statement -> FOR assignment_statement TO expression DO statement .

    SEMICOLON       reduce using rule 46 (for_statement -> FOR assignment_statement TO expression DO statement .)


state 145

    (47) for_statement -> FOR assignment_statement DOWNTO expression DO statement .

    SEMICOLON       reduce using rule 47 (for_statement -> FOR assignment_statement DOWNTO expression DO statement .)

